{"name":"Git-tutorial","tagline":"git tutorial","body":"Git version control tutorial.\r\n\r\nBSD 3-clause license.\r\n\r\nContributions are very welcome.\r\n\r\nThe current focus on Linux + [git](http://git-scm.com/) + [github][], you can use any OS (Windows or OSX), and there are many alternatives to [github], such as [bitbucket] or [gitorious].\r\n\r\n#souces\r\n\r\n- official book: <http://git-scm.com/book>.\r\n\r\n    Good info and graphs.\r\n\r\n    Leaves out many practical things.\r\n\r\n- good tut: <http://cworth.org/hgbook-git/tour/>\r\n\r\n- good tut, straight to the point, ascii diagrams: <http://www.sbf5.com/~cduan/technical/git/git-1.shtml>\r\n\r\n- good tut by github: <http://learn.github.com/p/>\r\n\r\n- description of a production/dev/hotfix branch model: <http://nvie.com/posts/a-successful-git-branching-model/>\r\n\r\n#motivation\r\n\r\nGit + Github allows you to do the following quickly:\r\n\r\n- [upload] your work to a server to:\r\n\r\n    - backup your work\r\n\r\n    - publish it\r\n\r\n- [download] something someone else made and put on a server\r\n\r\n- [go to another version]\r\n\r\n    - in case you make a mistake, you can restore any file you want, even if it was deleted.\r\n\r\n    - you can refer to a specific version.\r\n\r\n        Why is this useful?\r\n\r\n        Say you are writting a book, and you made a session called \"motivation\".\r\n\r\n        Other people liked it, and said, look at the motivation section!\r\n\r\n        But one day, you decide that the motivation section should be moved somewhere else.\r\n\r\n        But then this breakes the references of other people!\r\n\r\n        Not if the other person said: look at the \"motivation\" section of *version* XXX!\r\n\r\n- create alternate realities\r\n\r\n    this is useful when:\r\n\r\n    - you want to make two different modifications on a file but you think they may interfere with one another.\r\n\r\n        No problem, create one alternate reality version for each based on the current state.\r\n\r\n    - you want to contribute two modifictaions to someoneelse's project.\r\n\r\n        You are not sure which he will accept. So you make two alternate realities and suggest them both.\r\n\r\n- view differences between versions\r\n\r\n    it is easy to [view *differences* between versions](#differences) to find out what was different on a different version\r\n\r\n    this is useful when:\r\n\r\n    - why was my program working then, but stopped working?\r\n\r\n    - what changes exactly did someone else made to my files and wants me to accept?\r\n\r\n- work in groups\r\n\r\n    Because of all its capacitie, git is widely used in group projects. (it was *created* for the linux kernel )\r\n\r\n    This means that:\r\n\r\n    - you can make a very large project that need many people to work on the same code.\r\n\r\n    - you can learn from others.\r\n\r\n    - if you make a good work, you will get more famous, and will have better jobs.\r\n\r\n    For open source, this also means that:\r\n\r\n    - you can make modifications that you need to the program you use.\r\n\r\n#how to learn git\r\n\r\nGit is hard to learn at first because\r\n\r\n- it has inner state that is not obvious at first to visualize.\r\n\r\n- concepts depend on one another egg and chicken style.\r\n\r\nTo learn it:\r\n\r\n- make a bunch of standard test repos, copy them out, and *test away*.\r\n\r\n    use the standard repos generated in [test repos]\r\n\r\n- visualize the commit tree whenever you don't know what is going on.\r\n\r\n    once you see the tree, and how to modify it, everything falls into place!\r\n\r\n#setup\r\n\r\nBefore anything else install git.\r\n\r\nOn on ubuntu:\r\n\r\n    sudo aptitude insatll git\r\n\r\nNext configure git:\r\n\r\n    git config --global user.name \"Ciro Duran Santilli\"\r\n    git config --global user.email \"ciro@mail.com\"\r\n\r\nYou will also want to install a local gui git viewer:\r\n\r\n    sudo aptitude insatll gitk\r\n\r\nIt makes it easy to see certain things\r\n\r\n#repository\r\n\r\nGit works inside the dirs you tell it to work.\r\n\r\nThose dirs are called *repositories*, *repo* for short.\r\n\r\nTo create a new repo, use [init].\r\n\r\nTo copy an existin repo, use [clone]. No need to init it after you clone it.\r\n\r\nTo transform a repo into a non repo, remove the `.git` dir (and maybe other files like `.gitignore`)\r\n\r\n#init\r\n\r\nGo into some dir you have code you want to add to git and then do:\r\n\r\n    git init\r\n\r\nThis creates a `.git` dir that contains all the git information.\r\n\r\n#create version\r\n\r\nMost of git operations are based on versions, so you'd better know how to create them!\r\n\r\nTo create a version you need to:\r\n\r\n- decide what files will be included in the version with [add], [rm] or [reset]\r\n- create the version with [commit]\r\n\r\nYou can see what would be included in the next version with [status]\r\n\r\n#status\r\n\r\nAllows you to see what would be included in the next version\r\n\r\n    git status\r\n\r\nYou can change what would be added with commmands like [add], [rm] or [reset]\r\n\r\nThere are 3 possible sections:\r\n\r\n`Untracked files`\r\n\r\n:   files which have never been added in any version.\r\n\r\n`Changes not staged for commit`\r\n\r\n:   files which have changed but will not be considered.\r\n\r\n`Changes to be committed`\r\n\r\n:   files which which have changed and will be considered\r\n\r\nAnd if nothing changes, it says so.\r\n\r\nCheck out the [add], [rm] and [reset] commands to see how it behaves (it is only cool once you start changing the repo).\r\n\r\n#definition: index\r\n\r\nIs where git stores what will be kept for next version\r\n\r\nIt can modified with may commands such as [add], [rm], [mv], or [reset].\r\n\r\n#definition: working tree\r\n\r\nIs all the \"regular\" files that lie outside the `.git` dir.\r\n\r\n#ls-files\r\n\r\nList files according to several criteria\r\n\r\nShow tracked files:\r\n\r\n    ./copy.sh 1u\r\n    git ls-files\r\n        #a b\r\n\r\n#gitignore\r\n\r\nSee `man gitignore`\r\n\r\n`.gitignore` are files that tell git to ignore certain files, typically output files so they won't for example clutter your `git status`.\r\n\r\nA `.gitignore` can be put anywhere in the repo and affects current dir and all descendants.\r\n\r\nYou should *always* put all output files inside a gitignore.\r\n\r\nThere are two common strategies to to that:\r\n\r\n- by file extension\r\n\r\n    `*.o` to ignore all object files.\r\n\r\n    This is has the downside that you may have to add lots of extensions to the gitignore.\r\n\r\n- by directory\r\n\r\n    `_out/` to ignore all files in `_out/`.\r\n\r\n    This is has the downside that some (bad) programs cannot output to or use\r\n    files from other directories except the current...\r\n\r\n##syntax\r\n\r\n`.gitignore` uses slightly modified bash globbing. Reminders:\r\n\r\n- bash globbing is strictly less powerful than regexes\r\n\r\n- regex equivalence\r\n\r\n    glob        regex\r\n    --------    --------\r\n    `*`         `.*`\r\n    `*.o`       `.*\\.o`\r\n    `[1-3]`     `[1-3]`\r\n    `[a-c]`     `[a-c]`\r\n\r\n    so there is not equivalence for:\r\n\r\n    - regex kleene star: `*`\r\n    - regex alternatives: `(ab|cd)`\r\n\r\nIf a pattern does not contain a slash `/`, it matches any entire basename in any subdir:\r\n\r\n    echo a > .gitignore\r\n    git status\r\n        #untracked: b d/\r\n    git add d\r\n    git status\r\n        #untracked: b\r\n        #new file: d/b\r\n\r\nIf the pattern contains a slash `/`, only files under the given directory can match. E.g.: `d/*.c` matches `d/a.c` but not `d/e/a.c`.\r\n\r\nIf you want to ignore by basename under a given dir only, put a `.gitignore` into that dir.\r\n\r\nIf the pattern starts in `/`, only files under the same directory as the gitignore file can match. E.g.: `/*.c` matches `/a.c` but not `/d/a.c`.\r\n\r\nTrying to add an ignored file gives an error:\r\n\r\n    git reset\r\n    git add a\r\n        #error, a ignored, use -f if you really want to add it\r\n\r\nYou can ignore entire dirs:\r\n\r\n    echo d > .gitignore\r\n    git status\r\n        #untracked: a b\r\n\r\n`.gitignores` are valid on all subdirs of which it is put only:\r\n\r\n    echo a > d/.gitignore\r\n    git status\r\n        #untracked: a b d/\r\n    git add *\r\n    git status\r\n        #new file: a b d/b\r\n\r\n##local gitignore\r\n\r\n`.git/info/exclude`\r\n\r\nDoes not get pushed to remote.\r\n\r\nSame syntax as `.gitignore`.\r\n\r\n#add\r\n\r\nMake git track files for next version\r\n\r\n    add a\r\n    add a b\r\n\r\nCheck that it will be considered for next version with:\r\n\r\n    git status\r\n\r\n##example: add\r\n\r\nStart with [1]\r\n\r\n    echo a2 >> a\r\n\r\n    git status\r\n        #not staged: modified: a\r\n\r\n    git add a\r\n    git status\r\n        #to be committed: modified: a\r\n\r\nYou must add after making the desired modifications.\r\n\r\nIf you add and then modify, only the first addition will be taken into account for next version.\r\n\r\n    echo a2 >> a\r\n\r\n    git status\r\n        #to be committed: modified: a\r\n        #not staged:      modified: a\r\n\r\n    git add a\r\n\r\n    git status\r\n        #to be committed: modified: a\r\n\r\nAdd is recursive on dirs:\r\n\r\n    mkdir d\r\n    echo a > d/a\r\n    git status\r\n        #to be committed: modified: a\r\n        #untracked: d/\r\n\r\n    git add d\r\n    git status\r\n        #to be committed: modified: a\r\n        #to be committed: new: d/a\r\n\r\n##add and gitignore\r\n\r\nIf you add a file that is in `.gitignore` directly, the add fail.\r\n\r\nHowever, if you add a directory that contains gitignored files, then those files are ignored and the ignore succeeds.\r\n\r\nTherefore, for example to add all files in the current it is better to use:\r\n\r\n    git add .\r\n\r\nand not:\r\n\r\n    git add *\r\n\r\nwhich fails if there are gitignored files.\r\n\r\n`git add .` also has the advantage of including hidden dot files `.`.\r\n\r\n##combos\r\n\r\nAdd all nonhidden files in current dir:\r\n\r\n    git add *\r\n\r\nAdd all files in current dir, including hidden:\r\n\r\n    git add `ls -A`\r\n\r\n#rm\r\n\r\nIf you want to remove a file that is tracked from future versions then use:\r\n\r\n    git rm a\r\n\r\nA simple `rm a` will not remove it from next version.\r\n\r\nIf you already did `rm a`, then doing `git rm a` will work even if the file does not exist.\r\n\r\nNote however that this file still can be accessed on older versions!\r\n\r\nIf you committed sensitive data like passwords like this by mistake, you need to remove it from history too!\r\n\r\nTo do that see [remove file from repo history].\r\n\r\n##example: rm\r\n\r\nStart with [1]\r\n\r\n    rm a\r\n    git status\r\n        #not staged: removed a\r\n    echo b2 >> b\r\n    git add b\r\n    git commit -m 2\r\n\r\nThen `a` is still in the repo:\r\n\r\n    git checkout a\r\n\r\nRestores a.\r\n\r\nIf you use `commit -a`, it gets removed anyway:\r\n\r\n    rm a\r\n    git status\r\n        #not staged: removed a\r\n    echo b2 >> b\r\n    git add b\r\n    git commit -am 2\r\n\r\nYou could also `git add` or `git rm` after a bare `rm`:\r\n\r\n    rm a\r\n    git add a\r\n\r\nOr\r\n\r\n    rm a\r\n    git rm a\r\n\r\nAnd a will be removed.\r\n\r\n##rm --cached\r\n\r\nDon't remove the file from working tree, but stop tracking it for next commit.\r\n\r\n    ./copy.sh 1\r\n    git rm --cached b\r\n    git status\r\n        #to be commited: deleted: b\r\n        #untracked: b\r\n    git add b\r\n    git status\r\n        #nothing to be commited\r\n\r\n##rm -f\r\n\r\nRemove even if it has local changes.\r\n\r\nBy default this is not permitted.\r\n\r\n    ./copy.sh 1\r\n    echo a2 >> a\r\n    git rm a\r\n        #error: a has local modifications\r\n    git rm -r a\r\n    ls\r\n        #b\r\n\r\n##rm -r\r\n\r\nRemove all files descendants of a dir recursivelly.\r\n\r\nBy default, `git rm` won't remove dirs.\r\n\r\n#remove file from repo history\r\n\r\n[rm] does not remove files from repo history, only from future versions.\r\n\r\nSo if you mistakenly committed:\r\n\r\n- sensitive data like a password\r\n\r\n- some large output file like an `.ogv`\r\n\r\nDo this:\r\n\r\n    UNAME=cirosantilli\r\n    REPONAME=cpp\r\n    REPOURL=https://github.com/$UNAME/$REPONAME.git\r\n    RMFILE=\"*.ogv\"\r\n\r\n    git filter-branch --index-filter \"git rm --cached --ignore-unmatch \\\"$RMFILE\\\"\" --prune-empty -- --all\r\n\r\nRemove from local dir\r\n\r\n    rm -rf .git/refs/original/\r\n    git reflog expire --expire=now --all\r\n    git gc --prune=now\r\n    git gc --aggressive --prune=now\r\n\r\nRemove from repo:\r\n\r\n    git push origin master -f\r\n\r\n**Mail all colaborators** and tell them to git rebase\r\n\r\n#clean\r\n\r\n**danger**: remove all [untracked file]s in repo that are not in [gitignore]:\r\n\r\n    ./copy.sh 1\r\n\r\n    echo c > c\r\n    echo c > d/c\r\n\r\nDry run with `-n`:\r\n\r\n    git clean -n\r\n        #would remove c\r\n        #would not remove d/\r\n\r\nSince this is a very dangerous operation, in `Git 1.8` the default is to do dry runs. This can be controlled by the `clean.requireForce` configuration option, and an `-f` is required to actually clean. Do not rely on the value of this option.\r\n\r\nRemove entire dirs with `-d`:\r\n\r\n    git clean -dn\r\n        #would remove c\r\n        #would remove d/\r\n\r\nNot dry run with `-f`:\r\n\r\n    git clean -df\r\n        #would remove c\r\n        #would remove d/\r\n\r\nBy default, to make a non dry run, you have to add `-f`, but this depends on your git configurations.\r\n\r\nAlso remove untracked files listed in `.gitignore` with `-x`:\r\n\r\n    git clean -dfx\r\n\r\n#mv\r\n\r\nSimilar to [rm].\r\n\r\nIf you do a normal `mv`, then it is as if the old file was removed and a new one was created:\r\n\r\nStart with [1].\r\n\r\n    mv b c\r\n    git status\r\n        #removed: b\r\n        #untracked: b\r\n\r\nIf you do `git mv`, git acknowledges it was moved:\r\n\r\n    mv b c\r\n    git status\r\n        #renamed: b -> c\r\n\r\nWith `-f`, if the new path exists, it is overwritten:\r\n\r\n    git mv -f \"$OLD_PATH\" \"$NEW_PATH\"\r\n\r\nWith `-k`, if moving would lead to an error (overwrite without -f or file not tracked), skip the move:\r\n\r\n    git mv -k \"$OLD_PATH\" \"$NEW_PATH\"\r\n\r\n#reset\r\n\r\nMove the current branch and possibly index and working directory to one of its ancestor commits.\r\n\r\nChanges history.\r\n\r\nGreate explanation: <http://git-scm.com/blog>\r\n\r\nWithtout paths `git reset [option]`:\r\n\r\n- `--soft` moves the current branch to given ancestor commit.\r\n\r\n    It does not touch the index nor the working directory.\r\n\r\n    `git status` will show staged changes.\r\n\r\n- neither `--soft` nor `--hard` does what `--soft` does *and* changes the index to that commit. The working directory is unchanged.\r\n\r\n    `git status` will show unstaged changes.\r\n\r\n- neither `--hard` will move the current branch, the index *and* the working directory\r\n    to the given commit.\r\n\r\n    `git status` does not show any changes.\r\n\r\n    Changes were lost forever.\r\n\r\n##hard vs soft\r\n\r\nHard also modifies the actual files and the index!\r\n\r\nSoft does not.\r\n\r\n    ./copy.sh 2u\r\n    echo a3 >> a\r\n    echo b3 >> b\r\n    git add a b c\r\n    git status\r\n        #to be commited: a, b and c\r\n\r\nWith soft:\r\n\r\n    git reset\r\n        #unstaged: a, b\r\n        #untracked: c\r\n    ls\r\n        #a b c\r\n\r\n    cat a\r\n        #a1\r\n        #a2\r\n        #a3\r\n\r\n    cat b\r\n        #b1\r\n        #b2\r\n        #b3\r\n\r\n    cat c\r\n        #c\r\n\r\nSo all files stayed the same as they were, but they became unstaged.\r\n\r\nThis is how you unstage a file.\r\n\r\nWith hard:\r\n\r\n    git reset --hard\r\n    ls\r\n        #a b c\r\n\r\n    cat a\r\n        #a1\r\n        #a2\r\n\r\n    cat b\r\n        #b1\r\n        #b2\r\n\r\n    cat c\r\n        #c\r\n\r\n- tracked files went back to as they were at last commit.\r\n\r\n    Changes you made on the working tree were discarded!!\r\n\r\n- untracked files (`c`) are unchanged, but they are unstaged.\r\n\r\n##change what a branch points to\r\n\r\nThis changes history and as any history changing, if you do this after you [push] and someone else [fetche]d, there will be problems!\r\n\r\nWith reset, you can change the commit a branch points to to any other commit, Even if the other commit is not an ancestor of the parent!\r\n\r\n    ./copy.sh b2\r\n    git reset --hard b2\r\n    git status\r\n        #no changes\r\n\r\nThe tree:\r\n\r\n    (1)-----(2)\r\n     |\r\n     |\r\n     |\r\n     +------(b2)\r\n             |\r\n             master *\r\n             b\r\n\r\n###dangling commit\r\n\r\n`(2)` in this example is called a *dangling commit*.\r\n\r\nIt is a commit with no descendant branch.\r\n\r\n###delete last commit from history\r\n\r\nStart with [2]:\r\n\r\n    ./copy.sh 2\r\n    echo a3 >> a\r\n    echo b3 >> b\r\n    echo c > c\r\n    git reset --hard HEAD~\r\n    ls\r\n        #a b c\r\n\r\n    cat a\r\n        #a1\r\n\r\n    cat b\r\n        #b1\r\n\r\n    cat c\r\n        #c\r\n\r\n    git show-refs -h HEAD\r\n        #hash2\r\n\r\n    git log --pretty=oneline\r\n        #only one commit!\r\n\r\nThe tree:\r\n\r\n    (1)-----(2)\r\n     |\r\n     master *\r\n\r\nAnd `(2)` is called a dangling commit.\r\n\r\n##undo a reset hard\r\n\r\nYou *can* undo a reset hard if your are fast enough.\r\n\r\nFirst find out the hash of the deleted commits:\r\n\r\n    git fsck --lost-found\r\n\r\nThey should show up as *dangling commits*. This is what they are: commits that have no descendant branch.\r\n\r\nNow merge away with the have you just found.\r\n\r\nBut *don't rely on this!*: dangling commits are removed from time to time depending on your configs.\r\n\r\n##remove all dangling commits forever\r\n\r\n    git reflog expire --expire=now --all\r\n    git gc --prune=now\r\n\r\nBut be sure this is what you want! There is no turning back.\r\n\r\n#commit\r\n\r\nCreates a new version.\r\n\r\nYou must first which files will be included in it with commands like [add], [rm], [mv] and [reset].\r\n\r\nAfter you have decided what will be included or not, you are ready to commit.\r\n\r\nThis will be important later on to know what a version contains.\r\n\r\nSo from the [0] do:\r\n\r\n    git add a\r\n    git commit -m 'added a'\r\n    git status\r\n\r\nTo give it a message 'added a'.\r\n\r\nNow status only says that `b` is untracked and nothing about `a`.\r\n\r\n##commit message\r\n\r\nIt is recommended that the commit message be like:\r\n\r\n- start with a summary line of max 50 characters\r\n- black line\r\n- full explanation of the changes unless they are trivial.\r\n\r\nIn practice, commits usually link commit messages to the issue they fix, or rely on the Merge Request description for the extended information.\r\n\r\n##correct last commit\r\n\r\nIt is possible to modify the last commit with:\r\n\r\n    git commit --amend -m 'new msg'\r\n\r\nSee with `log` how this does not create new version.\r\n\r\nThis should only be used *before* pushing to a remote.\r\n\r\nTo change the commit message for commits further in the past, `git rebase -i` can be used.\r\n\r\n##commit all tracked files\r\n\r\n    git add -am 'message'\r\n\r\nWill create a new version, considering all files that are tracked (even if they were not added with add).\r\n\r\nIt is a very common default commit command.\r\n\r\nIf you use this all the time, you only add files once.\r\n\r\n#log\r\n\r\nList existing versions.\r\n\r\nStart with [2]. List versions in chronological order:\r\n\r\n    git log\r\n\r\nSample output:\r\n\r\n    commit 1ba8fcebbff0eb6140740c8e1cdb4f9ab5fb73b6\r\n    Author: Ciro Duran Santillli <ciro@mail.com>\r\n    Date:   Fri Apr 12 10:22:30 2013 +0200\r\n\r\n        2\r\n\r\n    commit 494b713f2bf320ffe034adc5515331803e22a8ae\r\n    Author: Ciro Duran Santillli <ciro@mail.com>\r\n    Date:   Thu Apr 11 15:50:38 2013 +0200\r\n\r\n        1\r\n\r\nIn this example, there are 2 versions, one with commit message `1` and another with commit message `2`.\r\n\r\nOn version `1` we see that:\r\n\r\n- author name: `Ciro Duran Santilli` (specified in `git config`)\r\n\r\n- author email: ciro@mail.com (specified in `git config`)\r\n\r\n- commit hash: `494b713f2bf320ffe034adc5515331803e22a8ae`.\r\n\r\n    If you don't know what a hash is, it is time to learn now!\r\n\r\n    Put simply, a hash is an angorithm that takes lots of input bytes (the repo)\r\n    and outputs a short string (aka \"the hash\"), and so that it is very hard\r\n    to find two inputs that have the same hash (altough they obviously exist,\r\n    because the ouput string is much smaller! )\r\n\r\nShow only if grepping commit messages match:\r\n\r\n    git log --grep 1\r\n\r\nShow all commits:\r\n\r\n    git log --all\r\n\r\nThis includes:\r\n\r\n- on other branches besides the current (by default only current branch is shown):\r\n- future commits when navigating history\r\n\r\nView hash and commit messages only, one per line:\r\n\r\n    git log --pretty=oneline\r\n\r\nUse a custom format string:\r\n\r\n    git log --pretty=format:\"The author of %h was %an, %ar%nThe title was >>%s<<%n\"\r\n\r\nSee `man git log` and grep for `format:` for a list of all formats.\r\n\r\nMost useful ones:\r\n\r\n- `%H`: full hash\r\n\r\nView deleted files only:\r\n\r\n    git log --diff-filter=D --summary\r\n    git log --all --pretty=format: --name-only --diff-filter=D\r\n\r\nThis is very useful to find when you deleted a file from a repo if you dont know its exact path!\r\n\r\nView up to a certain number of log messages (most recent):\r\n\r\n    git log -n 1\r\n\r\n`-n 1` is specially useful if you want to get information on the current commit,\r\nspecially when used with `pretty=format`.\r\n\r\nShow diff evolution of a single file:\r\n\r\n    git log -p file\r\n\r\nAlso cross `git mv`:\r\n\r\n    git log --follow -p file\r\n\r\nIf a merge occurs, both branches appear on `git log` and get mixed up\r\nchronologically and it is impossible to set them appart.\r\n\r\nTo show only history of the current branch ignoring merges do:\r\n\r\n    git log --first-parent\r\n\r\nThis is a great option to view history on a feature branch onto which upstream was merged from time to time. Rebase is a better option than merge in this case if you work locally, but may not be an option if a group is working on the feature branch.\r\n\r\n#shortlog\r\n\r\nSee how many commits each author did:\r\n\r\n    git shortlog -nse\r\n\r\n#grep\r\n\r\nDo a `grep -Er 'a.c' .` on tracked files of working tree:\r\n\r\n    git grep 'a.c\r\n\r\n#mailmap\r\n\r\nConfig file named `.mailmap` file at the repo root.\r\n\r\nAllows authors to change emails/usernames while keeping a single identity.\r\n\r\nPut lines like this in that file:\r\n\r\n    Old Name <old_email@mail.com> New Name <new_email@mail.com>\r\n\r\nThings will work well with this, for example [shortlog].\r\n\r\n#describe\r\n\r\nTODO\r\n\r\n#show\r\n\r\nShow specific versions of files and other infos.\r\n\r\nView file at an specific version:\r\n\r\n    git show HEAD^:path/to/file\r\n    git show $HASH^:path/to/file\r\n\r\nApplication: checkout a file with a diferent name:\r\n\r\n    git show HEAD^:path/to/file > new/path/to/file\r\n\r\n#reflog\r\n\r\nSee all that was done on repo linearly in time:\r\n\r\n    git reflog\r\n\r\nShows stuff like:\r\n\r\n- commits\r\n- checkouts\r\n- resets\r\n\r\n#gitk\r\n\r\nGitk is a gui for git.\r\n\r\nIt helps visualise commits and branches.\r\n\r\nShow commits on all branches:\r\n\r\n    gitk --all\r\n\r\n#rev names\r\n\r\nTo actually go to another version, you have to be able to tell git which one is it, so that git can go back to it.\r\n\r\nThere are a few ways to do that.\r\n\r\n##hash\r\n\r\nThe most complete is giving the entire hash, so:\r\n\r\n    1ba8fcebbff0eb6140740c8e1cdb4f9ab5fb73b6\r\n\r\nWould be version 2.\r\n\r\nThis is the [SHA] hash of the entire repo.\r\n\r\nFor those that do not know what a SHA hash is, keep in mind that it is very unlikelly that another version will have the same hash as this one.\r\n\r\nThe SHA input includes things like file contents, Commit times and authors, and tags. Therefore, even if the files are the same, SHAs willl probably be different.\r\n\r\nIf this is the only version that starts with `1ba8fc` or `1ba8`, (and it is) you could use those as well!\r\n\r\nGet the hash of the lastest commit:\r\n\r\n    git log -n1 --pretty=format:%H\r\n\r\n##HEAD\r\n\r\nThe `HEAD` is the current commit we are on.\r\n\r\nIt is possible to determine the current `HEAD` by doing `git branch`: the head will be the branch with an asterisk in front of it.\r\n\r\nInternally, the head is determined by the content of the file `$GIT/HEAD`, which is the hash of the current head commit.\r\n\r\n###example: HEAD\r\n\r\nStart with [1]. we have:\r\n\r\n    (1)\r\n     |\r\n     HEAD\r\n\r\nAfter another commit:\r\n\r\n    (1)-----(2)\r\n             |\r\n             HEAD\r\n\r\nAfter another commit:\r\n\r\n    (1)-----(2)-----(3)\r\n                     |\r\n                     HEAD\r\n\r\n##by tag\r\n\r\nSee [tag]\r\n\r\n##relative to another version\r\n\r\nOne commit before:\r\n\r\n    HEAD~\r\n\r\nTwo commits before:\r\n\r\n    HEAD~~\r\n    HEAD~2\r\n\r\nThree commits before:\r\n\r\n    HEAD~~~\r\n    HEAD~3\r\n\r\nAlso work:\r\n\r\n- hash:        `1ba8f~3`\r\n- branch:      `master~3`\r\n- tag:         `1.0~3`\r\n- remote head: `origin/master~3`\r\n- the previous position of branch `master`: `master@{1}`\r\n\r\nMoving forward is not unique since branch can split and have multiple children,\r\nso it is more complicated.\r\n\r\n##by branch\r\n\r\nTo understand branches, see [branch].\r\n\r\n##by remote head name\r\n\r\nSee [remote head]\r\n\r\n##name-rev\r\n\r\nIf you have the hash of a commit and you want a symbolic name for it, name-rev does that for you, probably looking for the closest named reference ahead of the commit.\r\n\r\nExample:\r\n\r\n    git name-rev 012345\r\n\r\nSample output:\r\n\r\n    012345 master~2\r\n\r\nExample:\r\n\r\n    git name-rev HEAD\r\n\r\nSample output:\r\n\r\n    012345 some-branch\r\n\r\n#diff\r\n\r\nSee differences between two versions with:\r\n\r\n    git diff eebb22 06637b\r\n\r\nSample output:\r\n\r\n    @@ 3,2 3,3 @@\r\n     before\r\n    +error\r\n     after\r\n\r\nMeaning:\r\n\r\n- before, line 3 was \"before\", line for \"after\".\r\n\r\n    there were 2 lines total in what we see\r\n\r\n- after, \"error\" was added after \"before\", becoming line 4\r\n\r\n    there will be 3 lines total in what we see\r\n\r\n    '+' indicates that a line was added.\r\n\r\n    not surprisingly, if we remove something, a '-' will show instead\r\n\r\nOn a single file:\r\n\r\n    git diff $C1 $C2 $F\r\n\r\nView staged differences (git added) and `HEAD`:\r\n\r\n    git diff --cached\r\n\r\nView unstaged modifications, that is, the diff between working tree and index (changes will disappear after `git add`):\r\n\r\n    git diff\r\n\r\nAfter a `git merge`, `git diff` shows a special mode that shows diffs to both parents:\r\n\r\n    +     Added in theirs\r\n    +     Added in theirs2\r\n     -    Removed in ours\r\n    ++    Added in both\r\n     +    Added in ours\r\n\r\n#tag\r\n\r\nTags are aliases to commits.\r\n\r\nThe difference from branches is that tags don't move with commits.\r\n\r\nTypical usage: give version numbers: `1.0`, `1.1`, `2.0`\r\n\r\n    ./copy 2\r\n\r\nThere are two types of tags, annoted and lightweight (unannoted).\r\n\r\nAnnoted tags have an associated message, author and creation date.\r\n\r\nYou cannot give a tag twice:\r\n\r\n    git tag 1.0\r\n    git tag 1.0 HEAD~\r\n\r\nSo you must delete the old tag before.\r\n\r\nA single commit can however have multiple tags.\r\n\r\n##give tags\r\n\r\nGive lightweight tag to `HEAD`:\r\n\r\n    git tag 2.0\r\n\r\nGive annoted tag to `HEAD`:\r\n\r\n    git tag -a 2.0 -m 'message'\r\n\r\nView associated information of annoted tag:\r\n\r\n    git show 2.0\r\n\r\nGive tag to another commit:\r\n\r\n    git tag 1.0 HEAD~\r\n\r\nGive another tag to that commit:\r\n\r\n    git tag 1.1 HEAD~\r\n\r\n##tag info\r\n\r\nList all tags:\r\n\r\n    git tag\r\n        #1.0\r\n        #1.0a\r\n        #1.1\r\n\r\nList tags and corresponding hashes side by side:\r\n\r\n    git show-ref --tags\r\n\r\nList with tags with corresponding commit messages side by side:\r\nnot possible without a for loop <http://stackoverflow.com/questions/5358336/have-git-list-all-tags-along-with-the-full-message>\r\n\r\n###describe\r\n\r\nFind out how many commits we are ahead of the latest tag:\r\n\r\n    git describe\r\n\r\nSample output:\r\n\r\n    v6.4.0.pre2-16-g41ae328\r\n\r\nFormat:\r\n\r\n    <tag>-<commits_ahead>-g<hash_start>\r\n\r\nGet the latest tag:\r\n\r\n    git describe --abbrev=0 --tags\r\n\r\nIf you want to use this programatically you could:\r\n\r\n    git describe --abbrev=0 --tags 2>/dev/null\r\n\r\nWhich ignores the error message in case there are no tags, so you get an empty result if there are no tags, and the latest tag if there is at least one tag.\r\n\r\n---\r\n\r\nGet a newline separated list of all tags for the latest commit, or empty if no tags are available:\r\n\r\n    git tag --contains HEAD\r\n\r\nSample output:\r\n\r\n    tag1\r\n    tag2\r\n\r\n##delete tags\r\n\r\nDelete a tag:\r\n\r\n    git tag -d 1.0\r\n\r\n##push tags to remote\r\n\r\nIs not done be default.\r\n\r\nMust do it with:\r\n\r\n    git push --tags\r\n\r\n##annotated tag\r\n\r\n    git tag -a ta -m 'annotated tag message!'\r\n\r\nAnd now:\r\n\r\n    git show ta\r\n\r\nWill show who created the tag and the tag message before the rest of the infos.\r\n\r\nA tag that is not annotated is called a `lightweight` tag.\r\n\r\n##signed\r\n\r\nGpg signed tags!!\r\n\r\nToo overkill/too lazy to show for here see: <http://learn.github.com/p/tagging.html>.\r\n\r\n#branch\r\n\r\nA branch is a name for a commit.\r\n\r\nThe commit a branch referst to may change.\r\n\r\nUsing branches you may split up the commit tree\r\n\r\nThis creates alternate realities so you  can test changes without one affecting the other.\r\n\r\nThe first commit of a repo is made on a branch called `master`\r\n\r\n##view existing branches\r\n\r\n    git branch\r\n\r\nNot the asterisk indicating which is the current branch.\r\n\r\nFor more info:\r\n\r\n    git branch -v\r\n\r\nAlso shows start of hash and commit message.\r\n\r\nOne very important way is to do is graphically:\r\n\r\n    gitk --all\r\n\r\nWill show you who is the descendant of whom!\r\n\r\n##create a branch\r\n\r\nCreate a branch called b:\r\n\r\n    git branch b\r\n\r\nCheck it was created:\r\n\r\n    git branch\r\n\r\nBut the asterisk shows we are still in branch `master`.\r\n\r\nThis does not move to the branch just created! to do so you must use:\r\n\r\n    git checkout b\r\n\r\n##create a and move to it\r\n\r\n    git checkout -b b\r\n    git branch\r\n\r\n##what happens when you create a branch\r\n\r\nTo the files, nothing.\r\n\r\nTo the tree, suppose we are [1u]\r\n\r\nThen after:\r\n\r\n    git branch b\r\n\r\nIt becomes:\r\n\r\n    (1)\r\n     |\r\n     master *\r\n     b\r\n\r\n##what happens to a branch when you commit\r\n\r\nThe *current* branch moves forward and continues being current.\r\n\r\nEx: start at [1ub] now:\r\n\r\n    git add c\r\n    git commit -am 'c'\r\n\r\nGives:\r\n\r\n    (1)-----(c)\r\n             |\r\n             master *\r\n\r\nNow try:\r\n\r\n    git checkout b\r\n\r\nWhich gives:\r\n\r\n    (1)-----(2)\r\n     |       |\r\n     b *     master\r\n\r\nC disappears because it was not tracked in b:\r\n\r\n    ls\r\n        #a b\r\n    echo c1 > c\r\n    git add c\r\n    git commit -m 'cb'\r\n\r\nAnd now we have:\r\n\r\n    +---------------(cb)\r\n    |                |\r\n   (1)-----(2)       b *\r\n            |\r\n            master\r\n\r\nWhich makes it obvious why a branch is called a branch.\r\n\r\n##detached head\r\n\r\nIs when you checkout to a commit that has no branch associated.\r\n\r\nEx: start with [2]\r\n\r\n    git checkout HEAD^\r\n\r\nNow see:\r\n\r\n    git branch\r\n\r\nShows current branch as:\r\n\r\n    (no branch) *\r\n\r\n###what should I do if I want to branch from the detached head\r\n\r\nIf you are on it, you should first create a branch:\r\n\r\n    git branch b\r\n\r\nThen work normally.\r\n\r\nYou can also create a branch before going to it with:\r\n\r\n    git branch <hash>\r\n\r\n###what happens if I commit on a detached head\r\n\r\nBad things! never do this!\r\n\r\nGit does commit, but stays on a undefined state.\r\n\r\nTo correct it you can create a branch:\r\n\r\n    git branch b\r\n\r\nAnd since you were on no branch, git automatically changes to `b`.\r\n\r\n####what if I commit and checkout??\r\n\r\nWorse things.\r\n\r\nYour old commit still exists, but does not show even on `git log --all`.\r\n\r\nGit warns you: this might be a good time to give it a branch, and you should as:\r\n\r\n    git branch b hash\r\n\r\n##start point\r\n\r\nYou can also create a branch at any commit other than the current one:\r\n\r\nTake [2]\r\n\r\n    git branch b HEAD~\r\n\r\nNow\r\n\r\n    git branch -v\r\n\r\nTo create switch to it directly:\r\n\r\n    git checkout -b b HEAD~\r\n\r\n##slash in branch name\r\n\r\nInside the `.git`, branches are placed under `refs`.\r\n\r\nIf you name a branch `a/b` it will create a file under `refs/a/b`.\r\n\r\nTherefore you can't both:\r\n\r\n- have a branch named `a`\r\n- have a branch names `a/b`\r\n\r\nsince `a` would have to be both a directory and a file at the same time for that to work.\r\n\r\n##rename a branch\r\n\r\nRename a given branch:\r\n\r\n    git branch -m oldname newname\r\n\r\nRename the current branch:\r\n\r\n    git branch -m newname\r\n\r\n#checkout\r\n\r\nGoes to another version\r\n\r\nBefore you go to another version, you must see which versions you can go back with [log] or [gitk].\r\n\r\n##entire repo\r\n\r\nUse the `checkout` command with some version name as explained in [how to refer to a version] for example:\r\n\r\n    git checkout 494b\r\n    git checkout HEAD~\r\n    git checkout master~\r\n\r\nThe command is called `checkout`, because we are goint to \"check out\" what another version was like.\r\n\r\nIf you checkout the entire repo, `HEAD` moves!\r\n\r\nIf you ommit the version, defaults to `HEAD` so:\r\n\r\n    git checkout\r\n    git checkout HEAD\r\n\r\nAre the same.\r\n\r\n###example: checkout entire repo\r\n\r\nStart with [3].\r\n\r\nIt looks like this:\r\n\r\n    (1)-----(2)-----(3)\r\n                     |\r\n                     master\r\n                     HEAD\r\n\r\nNow do:\r\n\r\n    git checkout HEAD~~\r\n\r\nThe files `a` and `b` now both contain one line!\r\n\r\n    cat a\r\n        #a1\r\n\r\n    cat b\r\n        #b1\r\n\r\nThe tree looks like this:\r\n\r\n    (1)-----(2)-----(3)\r\n     |               |\r\n     HEAD            master\r\n\r\nNote how the `HEAD` moved, but `master` did not!\r\n\r\nNow do:\r\n\r\n    git checkout master\r\n\r\nAnd `a` and `b` contain three lines again. This is how things look:\r\n\r\n    (1)-----(2)-----(3)\r\n                     |\r\n                     master\r\n                     HEAD\r\n\r\n    cat a\r\n        #a1\r\n\r\n    cat b\r\n        #b1\r\n\r\nFiles that are not tracked stay the same.\r\n\r\n###example: untracked files\r\n\r\nStart with [2]\r\n\r\n    echo -e 'c1\\nc2' > c\r\n\r\nNow checkout:\r\n\r\n    git checkout HEAD~\r\n\r\n`a` and `b` have changed\r\n\r\n    cat a\r\n        #a1\r\n\r\n    cat b\r\n        #b1\r\n\r\nBut the untracked `c` stays the same:\r\n\r\n    cat c\r\n        #c1\r\n        #c2\r\n\r\n###uncommited changes\r\n\r\nIf you have not yet commited changes, git warns you and does not checkout.\r\n\r\n####example: checkout uncommited modification\r\n\r\nStart with [2].\r\n\r\n    echo a3 >> a\r\n\r\nThen try:\r\n\r\n    git checkout HEAD~\r\n\r\nGit says that there is a change, and does nothing.\r\n\r\n####example: checkout file overwite\r\n\r\nStart with [2]\r\n\r\n    git rm a\r\n    git commit -am '-a'\r\n\r\n    git echo -e 'a1\\na2' > a\r\n\r\nThen try:\r\n\r\n    git checkout HEAD~~\r\n\r\nThis fails again, because file a would be overwritten, even if its contents did not change.\r\n\r\n##single file or dir\r\n\r\nJust like checking out the dir, but you also specify the files:\r\n\r\n    git checkout HEAD~ a b\r\n\r\nThe head does not move now! this is different from the behaviour of checkout [entire repo]\r\n\r\nNew files that appear are just like untracked ones.\r\n\r\n###example: checkout single file\r\n\r\nStart from [2]\r\n\r\n    git checkout HEAD^ a\r\n\r\n    cat a\r\n        #a1\r\n\r\nBut we are still at master:\r\n\r\n    git branch\r\n        #* master\r\n\r\n###example: checkout single removed file\r\n\r\nStart from [2]\r\n\r\nRemove b and commit:\r\n\r\n    git rm b\r\n    git commit -am '-b'\r\n\r\nNow restore it:\r\n\r\n    git checkout HEAD~ b\r\n\r\n    cat b\r\n        #b1\r\n        #b2\r\n\r\nThe file must exist in the version you want to checkout to.\r\n\r\n###counter-example: checkout after remove\r\n\r\n    start with [1]\r\n\r\n    git rm a\r\n    git commit -am 'noa`\r\n\r\nNo try:\r\n\r\n    git checkout a\r\n\r\nWhich is the same as:\r\n\r\n    git checkout HEAD -- a\r\n\r\nAnd it fails, because in `HEAD` a was removed from the repo.\r\n\r\n###uncommited changes\r\n\r\nUnlike when cheking out the entire repo, Git does not prompt you in case of non committed modifications When checking out individual files!\r\n\r\nThis is a great way to achieve data loss.\r\n\r\n###example: checkout single file with modifications\r\n\r\nStart from [2]\r\n\r\n    echo a3 >> a\r\n    git checkout\r\n\r\n#stash\r\n\r\nSaves all modifications which are not on the index and returns the working tree to `HEAD` into a modification stack called *stash*.\r\n\r\nThe changes can be applied to any branch afterwards.\r\n\r\nPush changes to the top of the stash:\r\n\r\n    git stash\r\n\r\nList stash:\r\n\r\n    git stash list\r\n\r\nApply change at the top of the stash:\r\n\r\n    git stash apply\r\n\r\n#merge\r\n\r\nIs when you take two branches and make a new one that is child of both.\r\n\r\nThere are certain mereges that are made automatcially:\r\n\r\n- file added\r\n- different lines of a file modified\r\n\r\nIf all merges can be done automatically, then you are prompted for a commit message the current head advances automatically to a new commit. This process is called fast forward.\r\n\r\nHowever there changes that cannot be merged automatically such as modification of a single line on both versions.\r\n\r\nIf that happens, and the file is not a binray file, the file on the tree be modified to contain:\r\n\r\n    <<<<<<< HEAD\r\n        config.password_length = 1..128\r\n    =======\r\n        config.password_length = 8..128\r\n    >>>>>>> other-branch\r\n\r\nand if you do `git status` you will see:\r\n\r\n    both modified: filename\r\n\r\nTo finish the merge you should check all of the both modified files, correct them, `git add` and then `git commit`.\r\n\r\nTo put the file into one of the two versions, you can do either:\r\n\r\n    git checkout --ours filename\r\n    git checkout --theirs filename\r\n\r\nThis is the most common solution for binary file conflicts.\r\n\r\nTo go back to the merge conflict version with `<<<<<< HEAD` you can do:\r\n\r\n    git checkout -m filename\r\n\r\nThis is what you do when you like the modifications of two branches!\r\n\r\n##strategies\r\n\r\nGit attempts to merge automatically using one of different merge strategies.\r\n\r\nSome strategies may require user intervention, while others never do.\r\n\r\nSome important strategies are:\r\n\r\n- ours: keeps local changes\r\n\r\n        git merge -s ours ref\r\n\r\n- theirs: keeps remote changes. Must be used with `-X` instead of `-s`, as discussed [here](http://stackoverflow.com/questions/173919/git-merge-s-ours-what-about-theirs)\r\n\r\n        git merge -X theirs ref\r\n\r\n##ignore certain files on merge\r\n\r\nRun:\r\n\r\n    `git config merge.ours.driver true`\r\n\r\nand use a `.gitattributes` as:\r\n\r\n    file_to_ignore merge=ours\r\n\r\n#push\r\n\r\nMakes changes on a [bare] remote repo.\r\n\r\nThe other repo can be on an external server like Github, or on your local filesystem.\r\n\r\nTypical changes possible with push:\r\n\r\n- put branches there\r\n- remove branches from there\r\n\r\nPush current branch to `remote` bare repo over branch `branch`:\r\n\r\n    git push remote branch\r\n\r\nwhere `remote` is anything that identifies the remote such as its url or name given by `add`.\r\n\r\nIf the remote branch does not exist it is created.\r\n\r\n###-u\r\n\r\nEach local branch can have a remote branch which it tracks, which is known as the upstream or tracked branch.\r\n\r\nPush and also set the upstream of current branch:\r\n\r\n    git push -u remote branch\r\n\r\nSet the upstream without push:\r\n\r\n    git branch --set-upstream remote branch\r\n\r\nThere seems to be no clean way to get the corresponding upstreams of all branches: <http://stackoverflow.com/questions/4950725/how-do-i-get-git-to-show-me-which-branches-are-tracking-what>\r\n\r\nThe best options are:\r\n\r\nInteractive for a single branch:\r\n\r\n    git branch -vv\r\n\r\nInteractive for all branches:\r\n\r\n    vim .git/config\r\n\r\nFor scripts for a single branch:\r\n\r\n    git rev-parse --abbrev-ref master@{upstream}\r\n\r\nPush current branch to its default upstream (remote/branch) pair\r\n\r\n    git push -u git@github.com:userid/reponame.git master\r\n\r\nWhat happens when you do:\r\n\r\n    git push\r\n\r\ndepends on the `push.default` option: <http://stackoverflow.com/questions/948354/git-push-default-behavior>\r\n\r\nThe default as of 1.8 is `simple`, which pushes to upstream only if the upstream branch name is the same as the current branch.\r\n\r\nPush all local branches which track a remote at `remote`:\r\n\r\n    git push remote\r\n\r\n##push -f\r\n\r\nPush to remote branch even if the remote branch is not a descendant of the local branch.\r\n\r\nI think this:\r\n\r\n- finds the closest common ancestor of the remote\r\n- makes everything that comes after a [dangling commit]\r\n- mounts the local changes on the command ancestor\r\n\r\nMay lead to data loss.\r\n\r\nExample:\r\n\r\n    ./clone.sh multi\r\n    cd a\r\n    git reset --hard HEAD~\r\n    git push\r\n        #does not work\r\n    git push -f\r\n        #works\r\n    git cd ../ao\r\n    git log --pretty=oneline\r\n        #we're on 1\r\n    git fsck --lost-found\r\n        #one dangling commit\r\n\r\n---\r\n\r\nPush all branches:\r\n\r\n    git push origin --all\r\n\r\nIt is possible to push the current branch by using:\r\n\r\n    git config push.default current\r\n\r\n##delete remote branch\r\n\r\n    git push origin --delete branch\r\n\r\n#remote\r\n\r\nManage remote repositories.\r\n\r\nWhen you clone something, it alreay has a remote called `origin`.\r\n\r\n##view remote\r\n\r\nShows remote repo aliases without their real addresses:\r\n\r\n    git remote\r\n\r\nShows remote repo aliases and their real addresses:\r\n\r\n    git remote -v\r\n\r\nView detail of branch:\r\n\r\n    git remote show $B\r\n\r\n##remote add\r\n\r\nOne way to avoid typing the repo url is giving it an alias with `remote add`:\r\n\r\n    git remote add origin git@github.com:userid/reponame.git\r\n\r\nOrigin can be any alias we want, but `origin` is a standard name for the main remote repo.\r\n\r\nAnd now you can do:\r\n\r\n    git push origin master\r\n\r\nYou can view existing aliases with:\r\n\r\n    git remote -v\r\n\r\nWhich gives:\r\n\r\n    origin  git@github.com:cirosantilli/reponame.git (fetch)\r\n    origin  git@github.com:cirosantilli/reponame.git (push)\r\n\r\n##modify remote\r\n\r\nRemove the remote branch called github:\r\n\r\n    git remote rm github\r\n\r\nChange the address of a remote:\r\n\r\n    git remote set-url git://github.com/username/projectname.git\r\n\r\n#remote head\r\n\r\nIs a head that has a name.\r\n\r\nIt is not a branch however!\r\n\r\nIf you checkout to them, you are in a detached head state.\r\n\r\n##how to get one\r\n\r\nSee [clone] and [fetch].\r\n\r\n##view remote branches\r\n\r\nFirst fetch the branches with:\r\n\r\n    git fetch remote\r\n\r\nView only remote branches, not local ones:\r\n\r\n    git branch -r\r\n\r\nView all branches, local and remote:\r\n\r\n    git branch -a\r\n\r\nThey are listed like `remote/\\<remote-name>/\\<branch-name>`\r\n\r\nWhere remote-name was either given:\r\n\r\n- explicitly by `remote add`\r\n- `origin` by default by `clone`\r\n\r\n##how to refer to one\r\n\r\nDepends on the command.\r\n\r\nThe best way is explicitly <remote-name>/<branch-name> but some commands do explicit stuff if you enter just <branch-name> and there is no other branch in your repo with that name.\r\n\r\nEx: `origin/master`, `origin/feature2`, `upstream/feature2`, etc.\r\n\r\n###branch\r\n\r\nBranch only sees remotes if you give the `remote-name` explicitly.\r\n\r\n###checkout\r\n\r\nIf you have a remote `origin/b` and no branch named `b`,\r\n\r\n    git checkout b\r\n\r\nIs the same as (magic!, never do this, it is very confuging!):\r\n\r\n    git checkout b origin/b\r\n\r\nBut:\r\n\r\n    git checkout -b b\r\n\r\nIs the same as:\r\n\r\n    git branch b\r\n    git checkout b\r\n\r\nIf you had a branch named `b`:\r\n\r\n    git checkout b\r\n\r\nWould simply go to it.\r\n\r\n#urls\r\n\r\nSee protocols.\r\n\r\n#protocols\r\n\r\nIf you can connect via SSH to a computer as:\r\n\r\n    ssh username@host\r\n\r\nthen you can do git operations as:\r\n\r\n    git username@host:/path/to/repo\r\n\r\nGithub git repo directories always end in `.git`, but this is just a convention. Also, in Github there is a single git user called git.\r\n\r\nOther methods of connection include:\r\n\r\n- HTTP over urls of type `http://`. Less efficient than the git protocol.\r\n- a git specific protocol with id `git://`. More efficient than HTTP since git specific,\r\n    but also requires a more specialized server.\r\n\r\n#clone\r\n\r\nMake a \"copy\" of another repo.\r\n\r\nFetchs all the remote branches.\r\n\r\nCreates only a single branch: the branch were the `HEAD` of the remote was.\r\n\r\n##example: clone and branches\r\n\r\nStart with [multi].\r\n\r\n    git clone a c\r\n\r\nCreates a repo c that is a \"copy\" of a. now:\r\n\r\n    cd c\r\n    branch -a\r\n        #master *\r\n        #remote/origin/b\r\n        #remote/origin/b2\r\n        #remote/origin/master\r\n\r\nSo you only have one branch, and the other are [remote head]s.\r\n\r\nBut if you do:\r\n\r\n    cd a\r\n    git checkout b\r\n    cd ..\r\n    git clone a d\r\n    cd d\r\n    git branch -a\r\n        #b *\r\n        #origin/b\r\n        #origin/b2\r\n        #origin/master\r\n\r\nThen you have a `b` branch, because that is where the head was when you cloned.\r\n\r\n##from github\r\n\r\nIt can also clone from a server such as github:\r\n\r\n    git clone git@github.com:userid/reponame.git newname\r\n\r\nThis is how you download a project which interests you.\r\n\r\n#fetch\r\n\r\nLooks for all modifications made on all branches of a remote and make them available on repo through [remote head]s.\r\n\r\nDoes not modify any branch on current repo.\r\n\r\nThe remote must have a name (either given automatically at `clone` as `origin` or through explicit `remote add`).\r\n\r\n##example\r\n\r\nState of the remote:\r\n\r\n    (A)----(B)----(C)----(H)\r\n                   |      |\r\n                   |      master *\r\n                   |\r\n                   +-----(E)\r\n                          |\r\n                          feature\r\n\r\nLocal repo after a clone:\r\n\r\n    git clone path/to/repo\r\n\r\n    (A)----(B)----(C)----(D)\r\n                   |      |\r\n                   |      master *\r\n                   |      origin/master\r\n                   |\r\n                   +-----(E)\r\n                          |\r\n                          origin/feature\r\n\r\nNew state of the remote:\r\n\r\n    (A)----(B)----(C)----(D)----(H)\r\n                   |             |\r\n                   |             master *\r\n                   |\r\n                   +-----(E)----(F)--------(G)\r\n                                            |\r\n                                            feature\r\n\r\nLocal repo after a fetch:\r\n\r\n    git fetch origin\r\n\r\n    (A)----(B)----(C)----(D)--------(H)\r\n                   |      |          |\r\n                   |      master *   origin/master\r\n                   |\r\n                   +-----(E)--------(F)--------(G)\r\n                          |                     |\r\n                          feature               origin/feature\r\n\r\n##remove a pushed remote branch\r\n\r\nIf you pushed a branch test by mistake, here is how you remove it:\r\n\r\n    git push origin :branchname\r\n\r\nJust add the colon before the branch name.\r\n\r\n#bare\r\n\r\nA repo that only contains the files that are inside `.git`.\r\n\r\nThis is what github stores for you: no need to store the files also!\r\n\r\nThere are some operations that you can only do/cannot do on a bare repo:\r\n\r\n- you can only push to a bare repo.\r\n\r\n    This means that using git to deploy a project requires a bare repository on the server + a post commit hook that will update the tree where desired.\r\n\r\n- you cannot pull from a bare repo.\r\n\r\nTo create a bare repo from scratch:\r\n\r\n    git init --bare\r\n\r\nTo create a bare repo that is a clone of another repo:\r\n\r\n    git clone --bare other\r\n\r\n#pull\r\n\r\nPull is exactly the same as [fetch] + [merge] on given branch and merges with current branch.\r\n\r\nDoes not update remote heads like [fetch] does.\r\n\r\n##example: pull\r\n\r\nState of the remote:\r\n\r\n    (A)----(B)----(C)----(H)\r\n                   |      |\r\n                   |      master *\r\n                   |\r\n                   +-----(E)\r\n                          |\r\n                          feature\r\n\r\nYour repo after a clone:\r\n\r\n    git clone path/to/repo\r\n\r\n    (A)----(B)----(C)----(D)\r\n                   |      |\r\n                   |      master *\r\n                   |      origin/master\r\n                   |\r\n                   +-----(E)\r\n                          |\r\n                          origin/feature\r\n\r\nNew state of the remote:\r\n\r\n    (A)----(B)----(C)----(D)----(H)\r\n                   |             |\r\n                   |             master *\r\n                   |\r\n                   +-----(E)----(F)--------(G)\r\n                                            |\r\n                                            feature\r\n\r\nLocal repo after a `merge`:\r\n\r\n    git pull origin master\r\n\r\n    (A)----(B)----(C)----(D)--------(H)\r\n                   |                 |\r\n                   |                 master *\r\n                   |                 origin/master\r\n                   |\r\n                   +-----(E)--------(F)--------(G)\r\n                          |                     |\r\n                          feature               origin/feature\r\n\r\nSo you current branch `master` has been merged into the branch `master` from repo `origin`.\r\n\r\n#push to github\r\n\r\nTo upload you must have an account on some server and you must have created.\r\n\r\nHere we show how to upload to [github].\r\n\r\n##github setup\r\n\r\nCreate an account. your userid is: `userid`\r\n\r\nCreate a repository. call it `reponame`\r\n\r\nDon't initilized it with a readme.\r\n\r\nThe git url is then `git@github.com:userid/reponame.git`\r\n\r\n##do the upload\r\n\r\nUpload the latest version to the server with:\r\n\r\n    git push git@github.com:userid/reponame.git master\r\n\r\nThis may ask for you github username and pass.\r\n\r\nGo back to github and browse your uploaded files to check that they are there.\r\n\r\n##github and tags\r\n\r\nIf you tag then you can refer have raw urls for tags.\r\n\r\n#file permissions\r\n\r\nGit keeps file permissions (rwx) as metadata inside the `.git` dir.\r\n\r\n#empty dirs\r\n\r\nGit ignores empty dirs.\r\n\r\nTo force git to keep a dir, add a file to it.\r\n\r\nPopular possibilities are:\r\n\r\n- `readme` file explaining why the dir is there after all!\r\n\r\n- `.gitkeep` file. It has absolutelly no special meaning for git, but is somewhat conventional.\r\n\r\n#symlinks\r\n\r\n##on push\r\n\r\nGit stores symlinks as files containing the link location + some metadata inside `.git` that indicates that it is a symlink.\r\n\r\n##on pull\r\n\r\nGit recreates the symlinks on local system.\r\n\r\nStart with [multi].\r\n\r\n    cd a\r\n    ln -s a c\r\n    git add c\r\n    git commit -am 'c'\r\n    git push\r\n\r\n    cd ..\r\n    git clone ao c\r\n    cd c\r\n    [ -s c ] && echo ok\r\n\r\n#submodules\r\n\r\nGit commands inside the submodule work just like git commands on a regular git repo!\r\n\r\n##application\r\n\r\nYou have 3 repos.\r\n\r\nYou want to use files from a certain versions of repo 1 in repos 2 and 3.\r\n\r\nThere is no reliable way to:\r\n\r\n- share a file between programs ( like `PATH` does for executable )\r\n- maintain different versions of a program ( like `virtualenv` does for python )\r\n\r\nSo you have to keep a copy of the shared repo for each using repo anyways.\r\n\r\n##creation\r\n\r\nYou have a latex `a.sty` file which you want to use.\r\n\r\n- on version `1.1` for a latex project 2 in `project2` repo\r\n- on version `1.0` for a latex project 3 in `project3` repo\r\n\r\nMake a repo and put `a.sty` in the repo. Call it `latex`.\r\n\r\nOn project 2:\r\n\r\n    git submodule add git://github.com/USERNAME/latex.git shared\r\n    ln -s shared/a.sty a.sty\r\n    git add .gitmodules\r\n\r\nNow a dir callled `shared` was created and contains your repo.\r\n\r\nDon't ever touch that dir directly. Changes in that dir are not seen by git.\r\n\r\n##clone a repo that contains a submodule\r\n\r\nTo get all the files of submodules you need the `--recursive` flag:\r\n\r\n    git clone --recursive git://github.com/USERNAME/project2.git\r\n\r\nIf you forgot to use recursive when you cloned, you should:\r\n\r\n    git submodule update --init\r\n\r\nIt seems that making clone recursive by default is neither possible nor a good idea: http://stackoverflow.com/questions/4251940/retrospectively-add-recursive-to-a-git-repo\r\n\r\n##update the content of a submodule\r\n\r\n    cd share\r\n    git pull\r\n\r\nNow we have:\r\n\r\n    git status\r\n        #modified:   shared (new commits)\r\n\r\nFor your repo to incorporate this update, you have to add the submodule path (`share/`) and commit, or simply do a `commit -a` next time.\r\n\r\nFrom the outside, the submodule looks much like a regular git controlled file.\r\n\r\nUpdate the contents of all submodules:\r\n\r\n    git submodule foreach git pull\r\n\r\nThis does not work if the modules are only listed under `.gitmodule` but have not been added to index with `add`.\r\n\r\n##foreach\r\n\r\nDo an arbritary command from each submodule directory.\r\n\r\nEx: updates all submodules:\r\n\r\n    git submodule foreach git pull\r\n\r\nPrint full paths of each submodule:\r\n\r\n    git submodule foreach pwd\r\n\r\n##go back to another version of a submodule\r\n\r\n    cd share\r\n    git log\r\n    git checkout VERSION-ID\r\n\r\n##remove a submodule\r\n\r\nTODO test this\r\n\r\nRemove it from the `.gitmodules` file:\r\n\r\n    vim .submodules\r\n\r\nRemove it from `.git/config`:\r\n\r\n    vim .git/config\r\n    rm --cached $path_to_submodule #(no trailing slash).\r\n    rm -Rf .git/modules/$path_to_submodule\r\n    git commit -am 'removed submodule'\r\n    rm -rf $path_to_submodule\r\n\r\nOf course, this is horrible, and it seems that as of git 1.8.3 there will be a `git deinit` command! TODO remove when true\r\n\r\n##change submodule upstream\r\n\r\nEdit `.gitmodules` to the correct upstream\r\n\r\n    git submodule sync\r\n    git submodule update\r\n\r\n##change submodule location\r\n\r\n<http://stackoverflow.com/questions/4604486/how-do-i-move-an-existing-git-submodule-within-a-git-repository>\r\n\r\n#rebase\r\n\r\nChange local history making it appear linear thus clearer.\r\n\r\nAs any history change, should only be done before pushing to a remote.\r\n\r\n##non interactive rebase\r\n\r\nGiven:\r\n\r\n    (A)----(B)----(C)\r\n            |      |\r\n            |      master *\r\n            |\r\n            +-----(D)\r\n                   |\r\n                   feature\r\n\r\nIf you do:\r\n\r\n    git checkout feature\r\n    git rebase master\r\n\r\nyou get:\r\n\r\n    (A)----(B)----(C)-------(D)\r\n                   |         |\r\n                   master    feature *\r\n\r\nTherefore the rebase changes the history, making it look linear and therefore easier to understand.\r\n\r\nThis is how you should incorporate upstreams changes on your feature branch before you make a pull request, followed often by a squash interactive rebase.\r\n\r\n##interactive rebase\r\n\r\n    git rebase -i HEAD~3\r\n\r\nOpens up a vim buffer where you can modify the all commits between `HEAD` and `HEAD~2` (total 3 commits).\r\n\r\nThe buffer should contain something like this:\r\n\r\n    pick fc95d59 last - 2 commit message\r\n    pick 81961e9 last - 1 commit message\r\n    pick d13a071 last commit message\r\n\r\n    # Rebase d57a363..d13a071 onto d57a363\r\n    #\r\n    # Commands:\r\n    #  p, pick = use commit\r\n    #  r, reword = use commit, but edit the commit message\r\n    #  e, edit = use commit, but stop for amending\r\n    #  s, squash = use commit, but meld into previous commit\r\n    #  f, fixup = like \"squash\", but discard this commit's log message\r\n    #  x, exec = run command (the rest of the line) using shell\r\n    #\r\n    # These lines can be re-ordered; they are executed from top to bottom.\r\n    #\r\n    # If you remove a line here THAT COMMIT WILL BE LOST.\r\n    #\r\n    # However, if you remove everything, the rebase will be aborted.\r\n    #\r\n    # Note that empty commits are commented out\r\n\r\n###edit\r\n\r\n`edit` can be used for example if we want to change a the commit message for `HEAD~` we edit that to:\r\n\r\n    pick fc95d59 last - 2 commit message\r\n    edit 81961e9 last - 1 commit message\r\n    pick d13a071 last commit message\r\n\r\nsave and quit.\r\n\r\nNow git puts us back as `HEAD~1`.\r\n\r\nWe can then:\r\n\r\n    git commit --amend -m 'new last - 1 commit message'\r\n\r\nWhen you are stisfied:\r\n\r\n    git rebase --continue\r\n\r\nIf you change your mind and think that it is better not to rebase do:\r\n\r\n    git rebase --abort\r\n\r\nIf you change your mind only about a single `commit`, but still want to change the others to:\r\n\r\n    git rebase --skip\r\n\r\nAnd we are back to `HEAD`.\r\n\r\nNow `git log --pretty=oneline -n3` gives:\r\n\r\n    fc95d59[...] last - 2 commit message\r\n    81961e9[...] new last - 1 commit message\r\n    d13a071[...] last commit message\r\n\r\n###squash\r\n\r\n`squash` can be used if you want to remove all trace of a commit.\r\n\r\n`squash` is useful when you are developping a feature locally and you want to save progress at several points in case you want to go back.\r\n\r\nWhen you are done, you can expose a single commit for the feature, which will be much more concise and useful to others (or at least people will konw that you can use `squash`).\r\n\r\nYou will also look much smarter, since it will seem that you did not make lots of trials before getting things right.\r\n\r\nIf we want to remove only the `HEAD~` from history we edit as:\r\n\r\n    pick fc95d59 last - 2 commit message\r\n    squash 81961e9 last - 1 commit message\r\n    pick d13a071 last commit message\r\n\r\nThis will open up another vim buffer like:\r\n\r\n    # This is a combination of 2 commits.\r\n    # The first commit's message is:\r\n\r\n    last -2 commit message\r\n\r\n    # This is the 2nd commit message:\r\n\r\n    last -1 commit message\r\n\r\n    #[more comments]\r\n\r\nBecause commits `HEAD~` and `HEAD~2` will be turned into one, it is likelly that the new message will be neither of the two.\r\n\r\nSo, erase all non comment lines and do something like:\r\n\r\n    last -1 and last -2 together\r\n    #[more comments]\r\n\r\nNow `git log --pretty=oneline -n2` gives sometehing like\r\n\r\n    fc95d59[...] last -1 and last -2 together\r\n    d13a071[...] last commit message\r\n\r\nIt is not possible to squash the last commit of a rebase:\r\n\r\n    squash fc95d59 last - 2 commit message\r\n    pick 81961e9 last - 1 commit message\r\n    pick d13a071 last commit message\r\n\r\nTo do that, it would be necessary to do a `git rabase -i HEAD~4`, and `pick` `HEAD~4`:\r\n\r\n    pick fc95d59 last - 2 commit message\r\n    squash fc95d59 last - 2 commit message\r\n    pick 81961e9 last - 1 commit message\r\n    pick d13a071 last commit message\r\n\r\n###reorder and delete\r\n\r\nIt is also possible to reorder and erase any commit on the commit list.\r\n\r\nAll you need to do is to change the line order or remove lines.\r\n\r\n#cherry pick\r\n\r\nMerge only certain commits from another branch.\r\n\r\nMerge only the last commit from the `other-branch` branch:\r\n\r\n    git cherry-pick other-branch\r\n\r\n#rerere\r\n\r\nTODO\r\n\r\n#hooks\r\n\r\nTake an action whenever something happens (a commit for example).\r\n\r\nCreate a hook, just add an executable file with a known hook name under `.git/hooks/`.\r\n\r\nThis executable may receive command line arguments which git uses to pass useful info to the executable.\r\n\r\nExample:\r\n\r\n    cd .git/hooks/\r\n    echo '#!/usr/bin/env bash\r\n\r\n    echo abc' > post-commit\r\n    chmod +x post-commit\r\n\r\nNow whenever you commit, you will see: abc on the terminal!\r\n\r\nSee: <http://git-scm.com/book/en/Customizing-Git-Git-Hooks> for other hook names.\r\n\r\nWhen hooks are executed on the remote they echo on the local shell as: `remote: <stdout>`.\r\n\r\n#git rev-parse\r\n\r\nSome useful commands to automate Git.\r\n\r\nGet full path of repo root:\r\n\r\n    ./copy.sh 1d\r\n    git rev-parse --show-toplevel\r\n        #`pwd`\r\n    cd d\r\n        #$(dirname $(pwd))\r\n\r\nGet what you need to cd to go to top level:\r\n\r\n    ./copy.sh 1d\r\n    git rev-parse --show-cdup\r\n        #\r\n    cd d\r\n    git rev-parse --show-cdup\r\n        #../\r\n\r\nPath to `.git` dir:\r\n\r\n    git rev-parse --git-dir\r\n\r\n#config\r\n\r\nAllows to get and set config data.\r\n\r\nMain config files:\r\n\r\n- `~/.gitconfig`: for all repos on current computer. `--global` option\r\n\r\n- `.git/config`: cur repo only.\r\n\r\nIt is a cfg file of type:\r\n\r\n    [group]\r\n        a = b\r\n        c = d\r\n\r\nCorresponding command lines of type:\r\n\r\n    group.a b\r\n    group.c d\r\n\r\n##commands\r\n\r\nList all non default configs set in those files:\r\n\r\n    git config -l\r\n\r\nGet single value:\r\n\r\n    git config --global --get user.name\r\n\r\nGet multiple values:\r\n\r\n    git config --global --get-all user.name user.email\r\n\r\n##most important fields\r\n\r\nUsename and email on commits:\r\n\r\n    git config --global user.name \"Ciro Duran Santilli\"\r\n    git config --global user.email \"ciro@mail.com\"\r\n\r\nRemember HTTP/HTTPS passwords for 15 minutes:\r\n\r\n    git config --global credential.helper cache\r\n\r\nRemember HTTP/HTTPS passwords for given time:\r\n\r\n    git config --global credential.helper \"cache --timeout=3600\"\r\n\r\nLet git color terminal output by default (but not if it goes to pipes, or the color escape chars might break programs): \r\n\r\n    git config --global color.ui auto\r\n\r\nPager to use: `core.pager`. `less` by default.\r\n\r\nEditor to use for commit and tag messages: `core.editor`\r\n\r\nDeal well with windows loved cr lf newlines: `core.autocrlf`\r\n\r\nPath of a global `.gititnore` file for all projects: `core.excludesfile`.\r\n\r\nCommit message template file path: `commit.template`\r\n\r\n###alias\r\n\r\nAlias:\r\n\r\n    git config --global alias.st status\r\n\r\nNow you can use the alias as:\r\n\r\n    git st\r\n\r\nYou can also alias to shell commands:\r\n\r\n    git config --global alias.pwd '!pwd'\r\n\r\nAnd this works:\r\n\r\n    git pwd\r\n\r\nIt is always executed at the repo root.\r\n\r\nThis allows for the very useful combom:\r\n\r\n    git config --global alias.exec '!exec '\r\n\r\nAllowing you to do any command at toplevel:\r\n\r\n    git exec make\r\n\r\n#gitattributes\r\n\r\nGitattributes are configs that apply only to specific paths, not the entire repo.\r\n\r\nIt can be put:\r\n\r\n- inside a `.gitattributes` file in the repo.\r\n- inside the `.git/info/attributes` file.\r\n\r\nExamples:\r\n\r\n    *.md diff=word\r\n\r\nAlways ignore remote version of cetain files on merge run:\r\n\r\n    `git config merge.ours.driver true`\r\n\r\nand use a `.gitattributes` as:\r\n\r\n    file_to_ignore merge=ours\r\n\r\n#github api v3 via curl\r\n\r\nGithub has an HTTP api, meaning you can do stuff on Github programatically such as listing, creating or removing repos.\r\n\r\nHere we show how to use the `curl` command line utility to do it.\r\n\r\nVars:\r\n\r\n    USER=user\r\n    REPO=repo\r\n    PASS=\r\n\r\n##get repo info\r\n\r\nLots of info:\r\n\r\n    curl -i https://api.github.com/users/$USER/repos\r\n\r\n##create git repo\r\n\r\n    USER=\r\n    REPO=\r\n    curl -u \"$USER\" https://api.github.com/user/repos -d '{\"name\":\"'$REPO'\"}'\r\n\r\nRepo name is the very minimal you must set, but you could also set other params such as:\r\n\r\n    curl -u \"$USER\" https://api.github.com/user/repos -d '{\r\n       \"name\": \"'\"$REPO\"'\",\r\n       \"description\": \"This is your first repo\",\r\n       \"homepage\": \"https://github.com\",\r\n       \"private\": false,\r\n       \"has_issues\": true,\r\n       \"has_wiki\": true,\r\n       \"has_downloads\": true\r\n    }'\r\n\r\nIts just JSON (remember, last item cannot end in a comma).\r\n\r\n##delete repo\r\n\r\n    curl -u \"$USER\" -X DELETE https://api.github.com/repos/$USER/$REPO\r\n\r\nCareful, it works!\r\n\r\nTODO\r\n\r\n#test repos\r\n\r\nUse those to test stuff.\r\n\r\nThey can be generated with the `generate-test-repos.sh` script\r\n\r\nThey are described here.\r\n\r\n##0\r\n\r\n2 files uncommitted\r\n\r\n    ls\r\n        #a b\r\n    cat a\r\n        #a1\r\n    cat b\r\n        #b1\r\n    git status\r\n        #untracked: a b\r\n\r\n##0du\r\n\r\nSame as [0], but with an untracked subdir d:\r\n\r\n    ls\r\n        #a b d\r\n    ls d\r\n        #a b\r\n    cat d/a\r\n        #da\r\n    cat d/b\r\n        #db\r\n\r\n    git status\r\n        #untracked: a b d/\r\n\r\n##1\r\n\r\nSame as [0], but commited.\r\n\r\n    ls\r\n        #a b\r\n    cat a\r\n        #a1\r\n    cat b\r\n        #b1\r\n    git status\r\n        #no changes\r\n\r\n    (1)\r\n     |\r\n     master\r\n\r\n##1d\r\n\r\nSame as [0d], but with all tracked.\r\n\r\n##1u\r\n\r\nSame as [1], but one untracked file `c` added.\r\n\r\n    ls\r\n        #a b c\r\n    cat a\r\n        #a1\r\n    cat b\r\n        #b1\r\n    cat c\r\n        #c1\r\n\r\n    git status\r\n        #untracked: c\r\n\r\n    (1)\r\n     |\r\n     master\r\n     HEAD\r\n\r\n##1ub\r\n\r\nSame as 1ub + one branch.\r\n\r\nCurrent branch is `master`.\r\n\r\n    ls\r\n        #a b c\r\n    cat a\r\n        #a1\r\n    cat b\r\n        #b1\r\n    cat c\r\n        #c1\r\n\r\n    git status\r\n        #untracked: c\r\n\r\n    (1)\r\n     |\r\n     master *\r\n     b\r\n\r\n##2\r\n\r\n2 commits and 2 files commited.\r\n\r\n    ls\r\n        #a b\r\n    cat a\r\n        #a1\r\n        #a2\r\n    cat b\r\n        #b1\r\n        #b2\r\n\r\n    git status\r\n        #no changes\r\n\r\n    (1)-----(2)\r\n             |\r\n             HEAD\r\n             master\r\n\r\n##2u\r\n\r\nSame as [2] + 1 file uncommited.\r\n\r\n    ls\r\n        #a b c\r\n    cat a\r\n        #a1\r\n        #a2\r\n    cat b\r\n        #b1\r\n        #b2\r\n    cat c\r\n        #c1\r\n        #c2\r\n\r\n    git status\r\n        #untracked: c\r\n\r\n    (1)-----(2)\r\n             |\r\n             HEAD\r\n             master\r\n\r\n##2b\r\n\r\nTwo branches unmerged, no uncommited files.\r\n\r\nTree:\r\n\r\n\r\n    (1)-----(2)\r\n     |       |\r\n     |       master *\r\n     |\r\n     +------(b2)\r\n             |\r\n             b\r\n\r\nFiles:\r\n\r\n    git checkout master\r\n\r\n    ls\r\n        #a b c\r\n    cat a\r\n        #a1\r\n    cat b\r\n        #b1\r\n    cat c\r\n        #c1\r\n\r\n    git checkout b\r\n\r\n    ls\r\n        #a b c\r\n    cat a\r\n        #a1\r\n        #a2\r\n    cat b\r\n        #\r\n    cat d\r\n        #d1\r\n\r\n##3\r\n\r\n3 commits 2 files.\r\n\r\nLooks like:\r\n\r\n    ls\r\n        #a b\r\n    cat a\r\n        #a1\r\n        #a2\r\n        #a3\r\n    cat b\r\n        #b1\r\n        #b2\r\n        #b3\r\n\r\n    git status\r\n        #no changes\r\n\r\n    (1)-----(2)-----(3)\r\n                     |\r\n                     master *\r\n\r\n##0bare\r\n\r\nBare repo.\r\n\r\n##multi\r\n\r\nContains multiple repos for inter repo tests.\r\n\r\nIt looks just like the github fork model!\r\n\r\nThe repos are:\r\n\r\n    ls\r\n        #a ao b bo\r\n\r\nWhere:\r\n\r\n- ao is the origin of a\r\n- ao is the origin of bo\r\n- bo is the origin of b\r\n- ao is the upstream of b\r\n\r\nSo that those represent:\r\n\r\n- a is the original repo (same as [b2])\r\n- ao is where the owner put it on github\r\n- bo is the fork made by someone else on github\r\n- b  is the clone of the fork\r\n\r\nAlso:\r\n\r\n- a has a branch `master` and a branch `b`\r\n\r\n##multiu\r\n\r\nLike [multi], but both master branches have commited unmerged modifications.\r\n\r\n#definitions\r\n\r\nSome git vocabulary.\r\n\r\n##a commit\r\n\r\nIs a version.\r\n\r\n##to commit\r\n\r\nIs to create version.\r\n\r\n##to stage a file\r\n\r\nIs to consider it for next commit.\r\n\r\n##tracked file\r\n\r\nIs one that has already been staged once.\r\n\r\n##upstream\r\n\r\nIn general however, upstream is the name for the main repository before you cloned it, `origin` being the name of your clone.\r\n\r\nFor example, if you forked `he/project` into `me/project`, and clone `me/project`, the upstream of the cloned repo should be `he/project`.\r\n\r\nIn `git`, *upstream* has an specific meaning for the `push` command. A better alternative name also used on the man page is *tracking* branch, so as not to confuse it with the usual `origin` `upstream` workflow terminology.\r\n\r\n#TODO\r\n\r\n- b clones, a commits, b commits. how can a check b's work\r\n(without clone! withou merge into master, but as a branch at first commit)?\r\n\r\n- how to update submodules automatically after a clone (with hooks maybe?)\r\n\r\n- how to automatically upload cross platform output files such as pdf (generated from latex)\r\n\r\n[github]: https://github.com/\r\n[bitbucket]: https://www.bitbucket.org/\r\n[gitorious]: http://gitorious.org/\r\n[vcs]: http://en.wikipedia.org/wiki/Revision_control\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}