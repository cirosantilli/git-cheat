<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Git-tutorial by cirosantilli</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/cirosantilli/git-tutorial">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/cirosantilli/git-tutorial/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/cirosantilli/git-tutorial/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Git-tutorial</h1>
          <p>git tutorial</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/cirosantilli">cirosantilli</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <p>Git version control tutorial.</p>

<p>BSD 3-clause license.</p>

<p>Contributions are very welcome.</p>

<p>The current focus on Linux + <a href="http://git-scm.com/">git</a> + <a href="https://github.com/">github</a>, you can use any OS (Windows or OSX), and there are many alternatives to <a href="https://github.com/">github</a>, such as <a href="https://www.bitbucket.org/">bitbucket</a> or <a href="http://gitorious.org/">gitorious</a>.</p>

<h1>
<a name="souces" class="anchor" href="#souces"><span class="octicon octicon-link"></span></a>souces</h1>

<ul>
<li>
<p>official book: <a href="http://git-scm.com/book">http://git-scm.com/book</a>.</p>

<p>Good info and graphs.</p>

<p>Leaves out many practical things.</p>
</li>
<li><p>good tut: <a href="http://cworth.org/hgbook-git/tour/">http://cworth.org/hgbook-git/tour/</a></p></li>
<li><p>good tut, straight to the point, ascii diagrams: <a href="http://www.sbf5.com/%7Ecduan/technical/git/git-1.shtml">http://www.sbf5.com/~cduan/technical/git/git-1.shtml</a></p></li>
<li><p>good tut by github: <a href="http://learn.github.com/p/">http://learn.github.com/p/</a></p></li>
<li><p>description of a production/dev/hotfix branch model: <a href="http://nvie.com/posts/a-successful-git-branching-model/">http://nvie.com/posts/a-successful-git-branching-model/</a></p></li>
</ul><h1>
<a name="motivation" class="anchor" href="#motivation"><span class="octicon octicon-link"></span></a>motivation</h1>

<p>Git + Github allows you to do the following quickly:</p>

<ul>
<li>
<p>[upload] your work to a server to:</p>

<ul>
<li><p>backup your work</p></li>
<li><p>publish it</p></li>
</ul>
</li>
<li><p>[download] something someone else made and put on a server</p></li>
<li>
<p>[go to another version]</p>

<ul>
<li><p>in case you make a mistake, you can restore any file you want, even if it was deleted.</p></li>
<li>
<p>you can refer to a specific version.</p>

<p>Why is this useful?</p>

<p>Say you are writting a book, and you made a session called "motivation".</p>

<p>Other people liked it, and said, look at the motivation section!</p>

<p>But one day, you decide that the motivation section should be moved somewhere else.</p>

<p>But then this breakes the references of other people!</p>

<p>Not if the other person said: look at the "motivation" section of <em>version</em> XXX!</p>
</li>
</ul>
</li>
<li>
<p>create alternate realities</p>

<p>this is useful when:</p>

<ul>
<li>
<p>you want to make two different modifications on a file but you think they may interfere with one another.</p>

<p>No problem, create one alternate reality version for each based on the current state.</p>
</li>
<li>
<p>you want to contribute two modifictaions to someoneelse's project.</p>

<p>You are not sure which he will accept. So you make two alternate realities and suggest them both.</p>
</li>
</ul>
</li>
<li>
<p>view differences between versions</p>

<p>it is easy to <a href="#differences">view <em>differences</em> between versions</a> to find out what was different on a different version</p>

<p>this is useful when:</p>

<ul>
<li><p>why was my program working then, but stopped working?</p></li>
<li><p>what changes exactly did someone else made to my files and wants me to accept?</p></li>
</ul>
</li>
<li>
<p>work in groups</p>

<p>Because of all its capacitie, git is widely used in group projects. (it was <em>created</em> for the linux kernel )</p>

<p>This means that:</p>

<ul>
<li><p>you can make a very large project that need many people to work on the same code.</p></li>
<li><p>you can learn from others.</p></li>
<li><p>if you make a good work, you will get more famous, and will have better jobs.</p></li>
</ul>
<p>For open source, this also means that:</p>

<ul>
<li>you can make modifications that you need to the program you use.</li>
</ul>
</li>
</ul><h1>
<a name="how-to-learn-git" class="anchor" href="#how-to-learn-git"><span class="octicon octicon-link"></span></a>how to learn git</h1>

<p>Git is hard to learn at first because</p>

<ul>
<li><p>it has inner state that is not obvious at first to visualize.</p></li>
<li><p>concepts depend on one another egg and chicken style.</p></li>
</ul><p>To learn it:</p>

<ul>
<li>
<p>make a bunch of standard test repos, copy them out, and <em>test away</em>.</p>

<p>use the standard repos generated in [test repos]</p>
</li>
<li>
<p>visualize the commit tree whenever you don't know what is going on.</p>

<p>once you see the tree, and how to modify it, everything falls into place!</p>
</li>
</ul><h1>
<a name="setup" class="anchor" href="#setup"><span class="octicon octicon-link"></span></a>setup</h1>

<p>Before anything else install git.</p>

<p>On on ubuntu:</p>

<pre><code>sudo aptitude insatll git
</code></pre>

<p>Next configure git:</p>

<pre><code>git config --global user.name "Ciro Duran Santilli"
git config --global user.email "ciro@mail.com"
</code></pre>

<p>You will also want to install a local gui git viewer:</p>

<pre><code>sudo aptitude insatll gitk
</code></pre>

<p>It makes it easy to see certain things</p>

<h1>
<a name="repository" class="anchor" href="#repository"><span class="octicon octicon-link"></span></a>repository</h1>

<p>Git works inside the dirs you tell it to work.</p>

<p>Those dirs are called <em>repositories</em>, <em>repo</em> for short.</p>

<p>To create a new repo, use [init].</p>

<p>To copy an existin repo, use [clone]. No need to init it after you clone it.</p>

<p>To transform a repo into a non repo, remove the <code>.git</code> dir (and maybe other files like <code>.gitignore</code>)</p>

<h1>
<a name="init" class="anchor" href="#init"><span class="octicon octicon-link"></span></a>init</h1>

<p>Go into some dir you have code you want to add to git and then do:</p>

<pre><code>git init
</code></pre>

<p>This creates a <code>.git</code> dir that contains all the git information.</p>

<h1>
<a name="create-version" class="anchor" href="#create-version"><span class="octicon octicon-link"></span></a>create version</h1>

<p>Most of git operations are based on versions, so you'd better know how to create them!</p>

<p>To create a version you need to:</p>

<ul>
<li>decide what files will be included in the version with [add], [rm] or [reset]</li>
<li>create the version with [commit]</li>
</ul><p>You can see what would be included in the next version with [status]</p>

<h1>
<a name="status" class="anchor" href="#status"><span class="octicon octicon-link"></span></a>status</h1>

<p>Allows you to see what would be included in the next version</p>

<pre><code>git status
</code></pre>

<p>You can change what would be added with commmands like [add], [rm] or [reset]</p>

<p>There are 3 possible sections:</p>

<p><code>Untracked files</code></p>

<p>:   files which have never been added in any version.</p>

<p><code>Changes not staged for commit</code></p>

<p>:   files which have changed but will not be considered.</p>

<p><code>Changes to be committed</code></p>

<p>:   files which which have changed and will be considered</p>

<p>And if nothing changes, it says so.</p>

<p>Check out the [add], [rm] and [reset] commands to see how it behaves (it is only cool once you start changing the repo).</p>

<h1>
<a name="definition-index" class="anchor" href="#definition-index"><span class="octicon octicon-link"></span></a>definition: index</h1>

<p>Is where git stores what will be kept for next version</p>

<p>It can modified with may commands such as [add], [rm], [mv], or [reset].</p>

<h1>
<a name="definition-working-tree" class="anchor" href="#definition-working-tree"><span class="octicon octicon-link"></span></a>definition: working tree</h1>

<p>Is all the "regular" files that lie outside the <code>.git</code> dir.</p>

<h1>
<a name="ls-files" class="anchor" href="#ls-files"><span class="octicon octicon-link"></span></a>ls-files</h1>

<p>List files according to several criteria</p>

<p>Show tracked files:</p>

<pre><code>./copy.sh 1u
git ls-files
    #a b
</code></pre>

<h1>
<a name="gitignore" class="anchor" href="#gitignore"><span class="octicon octicon-link"></span></a>gitignore</h1>

<p>See <code>man gitignore</code></p>

<p><code>.gitignore</code> are files that tell git to ignore certain files, typically output files so they won't for example clutter your <code>git status</code>.</p>

<p>A <code>.gitignore</code> can be put anywhere in the repo and affects current dir and all descendants.</p>

<p>You should <em>always</em> put all output files inside a gitignore.</p>

<p>There are two common strategies to to that:</p>

<ul>
<li>
<p>by file extension</p>

<p><code>*.o</code> to ignore all object files.</p>

<p>This is has the downside that you may have to add lots of extensions to the gitignore.</p>
</li>
<li>
<p>by directory</p>

<p><code>_out/</code> to ignore all files in <code>_out/</code>.</p>

<p>This is has the downside that some (bad) programs cannot output to or use
files from other directories except the current...</p>
</li>
</ul><h2>
<a name="syntax" class="anchor" href="#syntax"><span class="octicon octicon-link"></span></a>syntax</h2>

<p><code>.gitignore</code> uses slightly modified bash globbing. Reminders:</p>

<ul>
<li><p>bash globbing is strictly less powerful than regexes</p></li>
<li>
<p>regex equivalence</p>

<p>glob        regex</p>

<hr>
<p><code>*</code>         <code>.*</code>
<code>*.o</code>       <code>.*\.o</code>
<code>[1-3]</code>     <code>[1-3]</code>
<code>[a-c]</code>     <code>[a-c]</code></p>

<p>so there is not equivalence for:</p>

<ul>
<li>regex kleene star: <code>*</code>
</li>
<li>regex alternatives: <code>(ab|cd)</code>
</li>
</ul>
</li>
</ul><p>If a pattern does not contain a slash <code>/</code>, it matches any entire basename in any subdir:</p>

<pre><code>echo a &gt; .gitignore
git status
    #untracked: b d/
git add d
git status
    #untracked: b
    #new file: d/b
</code></pre>

<p>If the pattern contains a slash <code>/</code>, only files under the given directory can match. E.g.: <code>d/*.c</code> matches <code>d/a.c</code> but not <code>d/e/a.c</code>.</p>

<p>If you want to ignore by basename under a given dir only, put a <code>.gitignore</code> into that dir.</p>

<p>If the pattern starts in <code>/</code>, only files under the same directory as the gitignore file can match. E.g.: <code>/*.c</code> matches <code>/a.c</code> but not <code>/d/a.c</code>.</p>

<p>Trying to add an ignored file gives an error:</p>

<pre><code>git reset
git add a
    #error, a ignored, use -f if you really want to add it
</code></pre>

<p>You can ignore entire dirs:</p>

<pre><code>echo d &gt; .gitignore
git status
    #untracked: a b
</code></pre>

<p><code>.gitignores</code> are valid on all subdirs of which it is put only:</p>

<pre><code>echo a &gt; d/.gitignore
git status
    #untracked: a b d/
git add *
git status
    #new file: a b d/b
</code></pre>

<h2>
<a name="local-gitignore" class="anchor" href="#local-gitignore"><span class="octicon octicon-link"></span></a>local gitignore</h2>

<p><code>.git/info/exclude</code></p>

<p>Does not get pushed to remote.</p>

<p>Same syntax as <code>.gitignore</code>.</p>

<h1>
<a name="add" class="anchor" href="#add"><span class="octicon octicon-link"></span></a>add</h1>

<p>Make git track files for next version</p>

<pre><code>add a
add a b
</code></pre>

<p>Check that it will be considered for next version with:</p>

<pre><code>git status
</code></pre>

<h2>
<a name="example-add" class="anchor" href="#example-add"><span class="octicon octicon-link"></span></a>example: add</h2>

<p>Start with [1]</p>

<pre><code>echo a2 &gt;&gt; a

git status
    #not staged: modified: a

git add a
git status
    #to be committed: modified: a
</code></pre>

<p>You must add after making the desired modifications.</p>

<p>If you add and then modify, only the first addition will be taken into account for next version.</p>

<pre><code>echo a2 &gt;&gt; a

git status
    #to be committed: modified: a
    #not staged:      modified: a

git add a

git status
    #to be committed: modified: a
</code></pre>

<p>Add is recursive on dirs:</p>

<pre><code>mkdir d
echo a &gt; d/a
git status
    #to be committed: modified: a
    #untracked: d/

git add d
git status
    #to be committed: modified: a
    #to be committed: new: d/a
</code></pre>

<h2>
<a name="add-and-gitignore" class="anchor" href="#add-and-gitignore"><span class="octicon octicon-link"></span></a>add and gitignore</h2>

<p>If you add a file that is in <code>.gitignore</code> directly, the add fail.</p>

<p>However, if you add a directory that contains gitignored files, then those files are ignored and the ignore succeeds.</p>

<p>Therefore, for example to add all files in the current it is better to use:</p>

<pre><code>git add .
</code></pre>

<p>and not:</p>

<pre><code>git add *
</code></pre>

<p>which fails if there are gitignored files.</p>

<p><code>git add .</code> also has the advantage of including hidden dot files <code>.</code>.</p>

<h2>
<a name="combos" class="anchor" href="#combos"><span class="octicon octicon-link"></span></a>combos</h2>

<p>Add all nonhidden files in current dir:</p>

<pre><code>git add *
</code></pre>

<p>Add all files in current dir, including hidden:</p>

<pre><code>git add `ls -A`
</code></pre>

<h1>
<a name="rm" class="anchor" href="#rm"><span class="octicon octicon-link"></span></a>rm</h1>

<p>If you want to remove a file that is tracked from future versions then use:</p>

<pre><code>git rm a
</code></pre>

<p>A simple <code>rm a</code> will not remove it from next version.</p>

<p>If you already did <code>rm a</code>, then doing <code>git rm a</code> will work even if the file does not exist.</p>

<p>Note however that this file still can be accessed on older versions!</p>

<p>If you committed sensitive data like passwords like this by mistake, you need to remove it from history too!</p>

<p>To do that see [remove file from repo history].</p>

<h2>
<a name="example-rm" class="anchor" href="#example-rm"><span class="octicon octicon-link"></span></a>example: rm</h2>

<p>Start with [1]</p>

<pre><code>rm a
git status
    #not staged: removed a
echo b2 &gt;&gt; b
git add b
git commit -m 2
</code></pre>

<p>Then <code>a</code> is still in the repo:</p>

<pre><code>git checkout a
</code></pre>

<p>Restores a.</p>

<p>If you use <code>commit -a</code>, it gets removed anyway:</p>

<pre><code>rm a
git status
    #not staged: removed a
echo b2 &gt;&gt; b
git add b
git commit -am 2
</code></pre>

<p>You could also <code>git add</code> or <code>git rm</code> after a bare <code>rm</code>:</p>

<pre><code>rm a
git add a
</code></pre>

<p>Or</p>

<pre><code>rm a
git rm a
</code></pre>

<p>And a will be removed.</p>

<h2>
<a name="rm---cached" class="anchor" href="#rm---cached"><span class="octicon octicon-link"></span></a>rm --cached</h2>

<p>Don't remove the file from working tree, but stop tracking it for next commit.</p>

<pre><code>./copy.sh 1
git rm --cached b
git status
    #to be commited: deleted: b
    #untracked: b
git add b
git status
    #nothing to be commited
</code></pre>

<h2>
<a name="rm--f" class="anchor" href="#rm--f"><span class="octicon octicon-link"></span></a>rm -f</h2>

<p>Remove even if it has local changes.</p>

<p>By default this is not permitted.</p>

<pre><code>./copy.sh 1
echo a2 &gt;&gt; a
git rm a
    #error: a has local modifications
git rm -r a
ls
    #b
</code></pre>

<h2>
<a name="rm--r" class="anchor" href="#rm--r"><span class="octicon octicon-link"></span></a>rm -r</h2>

<p>Remove all files descendants of a dir recursivelly.</p>

<p>By default, <code>git rm</code> won't remove dirs.</p>

<h1>
<a name="remove-file-from-repo-history" class="anchor" href="#remove-file-from-repo-history"><span class="octicon octicon-link"></span></a>remove file from repo history</h1>

<p>[rm] does not remove files from repo history, only from future versions.</p>

<p>So if you mistakenly committed:</p>

<ul>
<li><p>sensitive data like a password</p></li>
<li><p>some large output file like an <code>.ogv</code></p></li>
</ul><p>Do this:</p>

<pre><code>UNAME=cirosantilli
REPONAME=cpp
REPOURL=https://github.com/$UNAME/$REPONAME.git
RMFILE="*.ogv"

git filter-branch --index-filter "git rm --cached --ignore-unmatch \"$RMFILE\"" --prune-empty -- --all
</code></pre>

<p>Remove from local dir</p>

<pre><code>rm -rf .git/refs/original/
git reflog expire --expire=now --all
git gc --prune=now
git gc --aggressive --prune=now
</code></pre>

<p>Remove from repo:</p>

<pre><code>git push origin master -f
</code></pre>

<p><strong>Mail all colaborators</strong> and tell them to git rebase</p>

<h1>
<a name="clean" class="anchor" href="#clean"><span class="octicon octicon-link"></span></a>clean</h1>

<p><strong>danger</strong>: remove all [untracked file]s in repo that are not in [gitignore]:</p>

<pre><code>./copy.sh 1

echo c &gt; c
echo c &gt; d/c
</code></pre>

<p>Dry run with <code>-n</code>:</p>

<pre><code>git clean -n
    #would remove c
    #would not remove d/
</code></pre>

<p>Since this is a very dangerous operation, in <code>Git 1.8</code> the default is to do dry runs. This can be controlled by the <code>clean.requireForce</code> configuration option, and an <code>-f</code> is required to actually clean. Do not rely on the value of this option.</p>

<p>Remove entire dirs with <code>-d</code>:</p>

<pre><code>git clean -dn
    #would remove c
    #would remove d/
</code></pre>

<p>Not dry run with <code>-f</code>:</p>

<pre><code>git clean -df
    #would remove c
    #would remove d/
</code></pre>

<p>By default, to make a non dry run, you have to add <code>-f</code>, but this depends on your git configurations.</p>

<p>Also remove untracked files listed in <code>.gitignore</code> with <code>-x</code>:</p>

<pre><code>git clean -dfx
</code></pre>

<h1>
<a name="mv" class="anchor" href="#mv"><span class="octicon octicon-link"></span></a>mv</h1>

<p>Similar to [rm].</p>

<p>If you do a normal <code>mv</code>, then it is as if the old file was removed and a new one was created:</p>

<p>Start with [1].</p>

<pre><code>mv b c
git status
    #removed: b
    #untracked: b
</code></pre>

<p>If you do <code>git mv</code>, git acknowledges it was moved:</p>

<pre><code>mv b c
git status
    #renamed: b -&gt; c
</code></pre>

<p>With <code>-f</code>, if the new path exists, it is overwritten:</p>

<pre><code>git mv -f "$OLD_PATH" "$NEW_PATH"
</code></pre>

<p>With <code>-k</code>, if moving would lead to an error (overwrite without -f or file not tracked), skip the move:</p>

<pre><code>git mv -k "$OLD_PATH" "$NEW_PATH"
</code></pre>

<h1>
<a name="reset" class="anchor" href="#reset"><span class="octicon octicon-link"></span></a>reset</h1>

<p>Move the current branch and possibly index and working directory to one of its ancestor commits.</p>

<p>Changes history.</p>

<p>Greate explanation: <a href="http://git-scm.com/blog">http://git-scm.com/blog</a></p>

<p>Withtout paths <code>git reset [option]</code>:</p>

<ul>
<li>
<p><code>--soft</code> moves the current branch to given ancestor commit.</p>

<p>It does not touch the index nor the working directory.</p>

<p><code>git status</code> will show staged changes.</p>
</li>
<li>
<p>neither <code>--soft</code> nor <code>--hard</code> does what <code>--soft</code> does <em>and</em> changes the index to that commit. The working directory is unchanged.</p>

<p><code>git status</code> will show unstaged changes.</p>
</li>
<li>
<p>neither <code>--hard</code> will move the current branch, the index <em>and</em> the working directory
to the given commit.</p>

<p><code>git status</code> does not show any changes.</p>

<p>Changes were lost forever.</p>
</li>
</ul><h2>
<a name="hard-vs-soft" class="anchor" href="#hard-vs-soft"><span class="octicon octicon-link"></span></a>hard vs soft</h2>

<p>Hard also modifies the actual files and the index!</p>

<p>Soft does not.</p>

<pre><code>./copy.sh 2u
echo a3 &gt;&gt; a
echo b3 &gt;&gt; b
git add a b c
git status
    #to be commited: a, b and c
</code></pre>

<p>With soft:</p>

<pre><code>git reset
    #unstaged: a, b
    #untracked: c
ls
    #a b c

cat a
    #a1
    #a2
    #a3

cat b
    #b1
    #b2
    #b3

cat c
    #c
</code></pre>

<p>So all files stayed the same as they were, but they became unstaged.</p>

<p>This is how you unstage a file.</p>

<p>With hard:</p>

<pre><code>git reset --hard
ls
    #a b c

cat a
    #a1
    #a2

cat b
    #b1
    #b2

cat c
    #c
</code></pre>

<ul>
<li>
<p>tracked files went back to as they were at last commit.</p>

<p>Changes you made on the working tree were discarded!!</p>
</li>
<li><p>untracked files (<code>c</code>) are unchanged, but they are unstaged.</p></li>
</ul><h2>
<a name="change-what-a-branch-points-to" class="anchor" href="#change-what-a-branch-points-to"><span class="octicon octicon-link"></span></a>change what a branch points to</h2>

<p>This changes history and as any history changing, if you do this after you [push] and someone else [fetche]d, there will be problems!</p>

<p>With reset, you can change the commit a branch points to to any other commit, Even if the other commit is not an ancestor of the parent!</p>

<pre><code>./copy.sh b2
git reset --hard b2
git status
    #no changes
</code></pre>

<p>The tree:</p>

<pre><code>(1)-----(2)
 |
 |
 |
 +------(b2)
         |
         master *
         b
</code></pre>

<h3>
<a name="dangling-commit" class="anchor" href="#dangling-commit"><span class="octicon octicon-link"></span></a>dangling commit</h3>

<p><code>(2)</code> in this example is called a <em>dangling commit</em>.</p>

<p>It is a commit with no descendant branch.</p>

<h3>
<a name="delete-last-commit-from-history" class="anchor" href="#delete-last-commit-from-history"><span class="octicon octicon-link"></span></a>delete last commit from history</h3>

<p>Start with [2]:</p>

<pre><code>./copy.sh 2
echo a3 &gt;&gt; a
echo b3 &gt;&gt; b
echo c &gt; c
git reset --hard HEAD~
ls
    #a b c

cat a
    #a1

cat b
    #b1

cat c
    #c

git show-refs -h HEAD
    #hash2

git log --pretty=oneline
    #only one commit!
</code></pre>

<p>The tree:</p>

<pre><code>(1)-----(2)
 |
 master *
</code></pre>

<p>And <code>(2)</code> is called a dangling commit.</p>

<h2>
<a name="undo-a-reset-hard" class="anchor" href="#undo-a-reset-hard"><span class="octicon octicon-link"></span></a>undo a reset hard</h2>

<p>You <em>can</em> undo a reset hard if your are fast enough.</p>

<p>First find out the hash of the deleted commits:</p>

<pre><code>git fsck --lost-found
</code></pre>

<p>They should show up as <em>dangling commits</em>. This is what they are: commits that have no descendant branch.</p>

<p>Now merge away with the have you just found.</p>

<p>But <em>don't rely on this!</em>: dangling commits are removed from time to time depending on your configs.</p>

<h2>
<a name="remove-all-dangling-commits-forever" class="anchor" href="#remove-all-dangling-commits-forever"><span class="octicon octicon-link"></span></a>remove all dangling commits forever</h2>

<pre><code>git reflog expire --expire=now --all
git gc --prune=now
</code></pre>

<p>But be sure this is what you want! There is no turning back.</p>

<h1>
<a name="commit" class="anchor" href="#commit"><span class="octicon octicon-link"></span></a>commit</h1>

<p>Creates a new version.</p>

<p>You must first which files will be included in it with commands like [add], [rm], [mv] and [reset].</p>

<p>After you have decided what will be included or not, you are ready to commit.</p>

<p>This will be important later on to know what a version contains.</p>

<p>So from the [0] do:</p>

<pre><code>git add a
git commit -m 'added a'
git status
</code></pre>

<p>To give it a message 'added a'.</p>

<p>Now status only says that <code>b</code> is untracked and nothing about <code>a</code>.</p>

<h2>
<a name="commit-message" class="anchor" href="#commit-message"><span class="octicon octicon-link"></span></a>commit message</h2>

<p>It is recommended that the commit message be like:</p>

<ul>
<li>start with a summary line of max 50 characters</li>
<li>black line</li>
<li>full explanation of the changes unless they are trivial.</li>
</ul><p>In practice, commits usually link commit messages to the issue they fix, or rely on the Merge Request description for the extended information.</p>

<h2>
<a name="correct-last-commit" class="anchor" href="#correct-last-commit"><span class="octicon octicon-link"></span></a>correct last commit</h2>

<p>It is possible to modify the last commit with:</p>

<pre><code>git commit --amend -m 'new msg'
</code></pre>

<p>See with <code>log</code> how this does not create new version.</p>

<p>This should only be used <em>before</em> pushing to a remote.</p>

<p>To change the commit message for commits further in the past, <code>git rebase -i</code> can be used.</p>

<h2>
<a name="commit-all-tracked-files" class="anchor" href="#commit-all-tracked-files"><span class="octicon octicon-link"></span></a>commit all tracked files</h2>

<pre><code>git add -am 'message'
</code></pre>

<p>Will create a new version, considering all files that are tracked (even if they were not added with add).</p>

<p>It is a very common default commit command.</p>

<p>If you use this all the time, you only add files once.</p>

<h1>
<a name="log" class="anchor" href="#log"><span class="octicon octicon-link"></span></a>log</h1>

<p>List existing versions.</p>

<p>Start with [2]. List versions in chronological order:</p>

<pre><code>git log
</code></pre>

<p>Sample output:</p>

<pre><code>commit 1ba8fcebbff0eb6140740c8e1cdb4f9ab5fb73b6
Author: Ciro Duran Santillli &lt;ciro@mail.com&gt;
Date:   Fri Apr 12 10:22:30 2013 +0200

    2

commit 494b713f2bf320ffe034adc5515331803e22a8ae
Author: Ciro Duran Santillli &lt;ciro@mail.com&gt;
Date:   Thu Apr 11 15:50:38 2013 +0200

    1
</code></pre>

<p>In this example, there are 2 versions, one with commit message <code>1</code> and another with commit message <code>2</code>.</p>

<p>On version <code>1</code> we see that:</p>

<ul>
<li><p>author name: <code>Ciro Duran Santilli</code> (specified in <code>git config</code>)</p></li>
<li><p>author email: <a href="mailto:ciro@mail.com">ciro@mail.com</a> (specified in <code>git config</code>)</p></li>
<li>
<p>commit hash: <code>494b713f2bf320ffe034adc5515331803e22a8ae</code>.</p>

<p>If you don't know what a hash is, it is time to learn now!</p>

<p>Put simply, a hash is an angorithm that takes lots of input bytes (the repo)
and outputs a short string (aka "the hash"), and so that it is very hard
to find two inputs that have the same hash (altough they obviously exist,
because the ouput string is much smaller! )</p>
</li>
</ul><p>Show only if grepping commit messages match:</p>

<pre><code>git log --grep 1
</code></pre>

<p>Show all commits:</p>

<pre><code>git log --all
</code></pre>

<p>This includes:</p>

<ul>
<li>on other branches besides the current (by default only current branch is shown):</li>
<li>future commits when navigating history</li>
</ul><p>View hash and commit messages only, one per line:</p>

<pre><code>git log --pretty=oneline
</code></pre>

<p>Use a custom format string:</p>

<pre><code>git log --pretty=format:"The author of %h was %an, %ar%nThe title was &gt;&gt;%s&lt;&lt;%n"
</code></pre>

<p>See <code>man git log</code> and grep for <code>format:</code> for a list of all formats.</p>

<p>Most useful ones:</p>

<ul>
<li>
<code>%H</code>: full hash</li>
</ul><p>View deleted files only:</p>

<pre><code>git log --diff-filter=D --summary
git log --all --pretty=format: --name-only --diff-filter=D
</code></pre>

<p>This is very useful to find when you deleted a file from a repo if you dont know its exact path!</p>

<p>View up to a certain number of log messages (most recent):</p>

<pre><code>git log -n 1
</code></pre>

<p><code>-n 1</code> is specially useful if you want to get information on the current commit,
specially when used with <code>pretty=format</code>.</p>

<p>Show diff evolution of a single file:</p>

<pre><code>git log -p file
</code></pre>

<p>Also cross <code>git mv</code>:</p>

<pre><code>git log --follow -p file
</code></pre>

<p>If a merge occurs, both branches appear on <code>git log</code> and get mixed up
chronologically and it is impossible to set them appart.</p>

<p>To show only history of the current branch ignoring merges do:</p>

<pre><code>git log --first-parent
</code></pre>

<p>This is a great option to view history on a feature branch onto which upstream was merged from time to time. Rebase is a better option than merge in this case if you work locally, but may not be an option if a group is working on the feature branch.</p>

<h1>
<a name="shortlog" class="anchor" href="#shortlog"><span class="octicon octicon-link"></span></a>shortlog</h1>

<p>See how many commits each author did:</p>

<pre><code>git shortlog -nse
</code></pre>

<h1>
<a name="grep" class="anchor" href="#grep"><span class="octicon octicon-link"></span></a>grep</h1>

<p>Do a <code>grep -Er 'a.c' .</code> on tracked files of working tree:</p>

<pre><code>git grep 'a.c
</code></pre>

<h1>
<a name="mailmap" class="anchor" href="#mailmap"><span class="octicon octicon-link"></span></a>mailmap</h1>

<p>Config file named <code>.mailmap</code> file at the repo root.</p>

<p>Allows authors to change emails/usernames while keeping a single identity.</p>

<p>Put lines like this in that file:</p>

<pre><code>Old Name &lt;old_email@mail.com&gt; New Name &lt;new_email@mail.com&gt;
</code></pre>

<p>Things will work well with this, for example [shortlog].</p>

<h1>
<a name="describe" class="anchor" href="#describe"><span class="octicon octicon-link"></span></a>describe</h1>

<p>TODO</p>

<h1>
<a name="show" class="anchor" href="#show"><span class="octicon octicon-link"></span></a>show</h1>

<p>Show specific versions of files and other infos.</p>

<p>View file at an specific version:</p>

<pre><code>git show HEAD^:path/to/file
git show $HASH^:path/to/file
</code></pre>

<p>Application: checkout a file with a diferent name:</p>

<pre><code>git show HEAD^:path/to/file &gt; new/path/to/file
</code></pre>

<h1>
<a name="reflog" class="anchor" href="#reflog"><span class="octicon octicon-link"></span></a>reflog</h1>

<p>See all that was done on repo linearly in time:</p>

<pre><code>git reflog
</code></pre>

<p>Shows stuff like:</p>

<ul>
<li>commits</li>
<li>checkouts</li>
<li>resets</li>
</ul><h1>
<a name="gitk" class="anchor" href="#gitk"><span class="octicon octicon-link"></span></a>gitk</h1>

<p>Gitk is a gui for git.</p>

<p>It helps visualise commits and branches.</p>

<p>Show commits on all branches:</p>

<pre><code>gitk --all
</code></pre>

<h1>
<a name="rev-names" class="anchor" href="#rev-names"><span class="octicon octicon-link"></span></a>rev names</h1>

<p>To actually go to another version, you have to be able to tell git which one is it, so that git can go back to it.</p>

<p>There are a few ways to do that.</p>

<h2>
<a name="hash" class="anchor" href="#hash"><span class="octicon octicon-link"></span></a>hash</h2>

<p>The most complete is giving the entire hash, so:</p>

<pre><code>1ba8fcebbff0eb6140740c8e1cdb4f9ab5fb73b6
</code></pre>

<p>Would be version 2.</p>

<p>This is the [SHA] hash of the entire repo.</p>

<p>For those that do not know what a SHA hash is, keep in mind that it is very unlikelly that another version will have the same hash as this one.</p>

<p>The SHA input includes things like file contents, Commit times and authors, and tags. Therefore, even if the files are the same, SHAs willl probably be different.</p>

<p>If this is the only version that starts with <code>1ba8fc</code> or <code>1ba8</code>, (and it is) you could use those as well!</p>

<p>Get the hash of the lastest commit:</p>

<pre><code>git log -n1 --pretty=format:%H
</code></pre>

<h2>
<a name="head" class="anchor" href="#head"><span class="octicon octicon-link"></span></a>HEAD</h2>

<p>The <code>HEAD</code> is the current commit we are on.</p>

<p>It is possible to determine the current <code>HEAD</code> by doing <code>git branch</code>: the head will be the branch with an asterisk in front of it.</p>

<p>Internally, the head is determined by the content of the file <code>$GIT/HEAD</code>, which is the hash of the current head commit.</p>

<h3>
<a name="example-head" class="anchor" href="#example-head"><span class="octicon octicon-link"></span></a>example: HEAD</h3>

<p>Start with [1]. we have:</p>

<pre><code>(1)
 |
 HEAD
</code></pre>

<p>After another commit:</p>

<pre><code>(1)-----(2)
         |
         HEAD
</code></pre>

<p>After another commit:</p>

<pre><code>(1)-----(2)-----(3)
                 |
                 HEAD
</code></pre>

<h2>
<a name="by-tag" class="anchor" href="#by-tag"><span class="octicon octicon-link"></span></a>by tag</h2>

<p>See [tag]</p>

<h2>
<a name="relative-to-another-version" class="anchor" href="#relative-to-another-version"><span class="octicon octicon-link"></span></a>relative to another version</h2>

<p>One commit before:</p>

<pre><code>HEAD~
</code></pre>

<p>Two commits before:</p>

<pre><code>HEAD~~
HEAD~2
</code></pre>

<p>Three commits before:</p>

<pre><code>HEAD~~~
HEAD~3
</code></pre>

<p>Also work:</p>

<ul>
<li>hash:        <code>1ba8f~3</code>
</li>
<li>branch:      <code>master~3</code>
</li>
<li>tag:         <code>1.0~3</code>
</li>
<li>remote head: <code>origin/master~3</code>
</li>
<li>the previous position of branch <code>master</code>: <code>master@{1}</code>
</li>
</ul><p>Moving forward is not unique since branch can split and have multiple children,
so it is more complicated.</p>

<h2>
<a name="by-branch" class="anchor" href="#by-branch"><span class="octicon octicon-link"></span></a>by branch</h2>

<p>To understand branches, see [branch].</p>

<h2>
<a name="by-remote-head-name" class="anchor" href="#by-remote-head-name"><span class="octicon octicon-link"></span></a>by remote head name</h2>

<p>See [remote head]</p>

<h2>
<a name="name-rev" class="anchor" href="#name-rev"><span class="octicon octicon-link"></span></a>name-rev</h2>

<p>If you have the hash of a commit and you want a symbolic name for it, name-rev does that for you, probably looking for the closest named reference ahead of the commit.</p>

<p>Example:</p>

<pre><code>git name-rev 012345
</code></pre>

<p>Sample output:</p>

<pre><code>012345 master~2
</code></pre>

<p>Example:</p>

<pre><code>git name-rev HEAD
</code></pre>

<p>Sample output:</p>

<pre><code>012345 some-branch
</code></pre>

<h1>
<a name="diff" class="anchor" href="#diff"><span class="octicon octicon-link"></span></a>diff</h1>

<p>See differences between two versions with:</p>

<pre><code>git diff eebb22 06637b
</code></pre>

<p>Sample output:</p>

<pre><code>@@ 3,2 3,3 @@
 before
+error
 after
</code></pre>

<p>Meaning:</p>

<ul>
<li>
<p>before, line 3 was "before", line for "after".</p>

<p>there were 2 lines total in what we see</p>
</li>
<li>
<p>after, "error" was added after "before", becoming line 4</p>

<p>there will be 3 lines total in what we see</p>

<p>'+' indicates that a line was added.</p>

<p>not surprisingly, if we remove something, a '-' will show instead</p>
</li>
</ul><p>On a single file:</p>

<pre><code>git diff $C1 $C2 $F
</code></pre>

<p>View staged differences (git added) and <code>HEAD</code>:</p>

<pre><code>git diff --cached
</code></pre>

<p>View unstaged modifications, that is, the diff between working tree and index (changes will disappear after <code>git add</code>):</p>

<pre><code>git diff
</code></pre>

<p>After a <code>git merge</code>, <code>git diff</code> shows a special mode that shows diffs to both parents:</p>

<pre><code>+     Added in theirs
+     Added in theirs2
 -    Removed in ours
++    Added in both
 +    Added in ours
</code></pre>

<h1>
<a name="tag" class="anchor" href="#tag"><span class="octicon octicon-link"></span></a>tag</h1>

<p>Tags are aliases to commits.</p>

<p>The difference from branches is that tags don't move with commits.</p>

<p>Typical usage: give version numbers: <code>1.0</code>, <code>1.1</code>, <code>2.0</code></p>

<pre><code>./copy 2
</code></pre>

<p>There are two types of tags, annoted and lightweight (unannoted).</p>

<p>Annoted tags have an associated message, author and creation date.</p>

<p>You cannot give a tag twice:</p>

<pre><code>git tag 1.0
git tag 1.0 HEAD~
</code></pre>

<p>So you must delete the old tag before.</p>

<p>A single commit can however have multiple tags.</p>

<h2>
<a name="give-tags" class="anchor" href="#give-tags"><span class="octicon octicon-link"></span></a>give tags</h2>

<p>Give lightweight tag to <code>HEAD</code>:</p>

<pre><code>git tag 2.0
</code></pre>

<p>Give annoted tag to <code>HEAD</code>:</p>

<pre><code>git tag -a 2.0 -m 'message'
</code></pre>

<p>View associated information of annoted tag:</p>

<pre><code>git show 2.0
</code></pre>

<p>Give tag to another commit:</p>

<pre><code>git tag 1.0 HEAD~
</code></pre>

<p>Give another tag to that commit:</p>

<pre><code>git tag 1.1 HEAD~
</code></pre>

<h2>
<a name="tag-info" class="anchor" href="#tag-info"><span class="octicon octicon-link"></span></a>tag info</h2>

<p>List all tags:</p>

<pre><code>git tag
    #1.0
    #1.0a
    #1.1
</code></pre>

<p>List tags and corresponding hashes side by side:</p>

<pre><code>git show-ref --tags
</code></pre>

<p>List with tags with corresponding commit messages side by side:
not possible without a for loop <a href="http://stackoverflow.com/questions/5358336/have-git-list-all-tags-along-with-the-full-message">http://stackoverflow.com/questions/5358336/have-git-list-all-tags-along-with-the-full-message</a></p>

<h3>
<a name="describe-1" class="anchor" href="#describe-1"><span class="octicon octicon-link"></span></a>describe</h3>

<p>Find out how many commits we are ahead of the latest tag:</p>

<pre><code>git describe
</code></pre>

<p>Sample output:</p>

<pre><code>v6.4.0.pre2-16-g41ae328
</code></pre>

<p>Format:</p>

<pre><code>&lt;tag&gt;-&lt;commits_ahead&gt;-g&lt;hash_start&gt;
</code></pre>

<p>Get the latest tag:</p>

<pre><code>git describe --abbrev=0 --tags
</code></pre>

<p>If you want to use this programatically you could:</p>

<pre><code>git describe --abbrev=0 --tags 2&gt;/dev/null
</code></pre>

<p>Which ignores the error message in case there are no tags, so you get an empty result if there are no tags, and the latest tag if there is at least one tag.</p>

<hr><p>Get a newline separated list of all tags for the latest commit, or empty if no tags are available:</p>

<pre><code>git tag --contains HEAD
</code></pre>

<p>Sample output:</p>

<pre><code>tag1
tag2
</code></pre>

<h2>
<a name="delete-tags" class="anchor" href="#delete-tags"><span class="octicon octicon-link"></span></a>delete tags</h2>

<p>Delete a tag:</p>

<pre><code>git tag -d 1.0
</code></pre>

<h2>
<a name="push-tags-to-remote" class="anchor" href="#push-tags-to-remote"><span class="octicon octicon-link"></span></a>push tags to remote</h2>

<p>Is not done be default.</p>

<p>Must do it with:</p>

<pre><code>git push --tags
</code></pre>

<h2>
<a name="annotated-tag" class="anchor" href="#annotated-tag"><span class="octicon octicon-link"></span></a>annotated tag</h2>

<pre><code>git tag -a ta -m 'annotated tag message!'
</code></pre>

<p>And now:</p>

<pre><code>git show ta
</code></pre>

<p>Will show who created the tag and the tag message before the rest of the infos.</p>

<p>A tag that is not annotated is called a <code>lightweight</code> tag.</p>

<h2>
<a name="signed" class="anchor" href="#signed"><span class="octicon octicon-link"></span></a>signed</h2>

<p>Gpg signed tags!!</p>

<p>Too overkill/too lazy to show for here see: <a href="http://learn.github.com/p/tagging.html">http://learn.github.com/p/tagging.html</a>.</p>

<h1>
<a name="branch" class="anchor" href="#branch"><span class="octicon octicon-link"></span></a>branch</h1>

<p>A branch is a name for a commit.</p>

<p>The commit a branch referst to may change.</p>

<p>Using branches you may split up the commit tree</p>

<p>This creates alternate realities so you  can test changes without one affecting the other.</p>

<p>The first commit of a repo is made on a branch called <code>master</code></p>

<h2>
<a name="view-existing-branches" class="anchor" href="#view-existing-branches"><span class="octicon octicon-link"></span></a>view existing branches</h2>

<pre><code>git branch
</code></pre>

<p>Not the asterisk indicating which is the current branch.</p>

<p>For more info:</p>

<pre><code>git branch -v
</code></pre>

<p>Also shows start of hash and commit message.</p>

<p>One very important way is to do is graphically:</p>

<pre><code>gitk --all
</code></pre>

<p>Will show you who is the descendant of whom!</p>

<h2>
<a name="create-a-branch" class="anchor" href="#create-a-branch"><span class="octicon octicon-link"></span></a>create a branch</h2>

<p>Create a branch called b:</p>

<pre><code>git branch b
</code></pre>

<p>Check it was created:</p>

<pre><code>git branch
</code></pre>

<p>But the asterisk shows we are still in branch <code>master</code>.</p>

<p>This does not move to the branch just created! to do so you must use:</p>

<pre><code>git checkout b
</code></pre>

<h2>
<a name="create-a-and-move-to-it" class="anchor" href="#create-a-and-move-to-it"><span class="octicon octicon-link"></span></a>create a and move to it</h2>

<pre><code>git checkout -b b
git branch
</code></pre>

<h2>
<a name="what-happens-when-you-create-a-branch" class="anchor" href="#what-happens-when-you-create-a-branch"><span class="octicon octicon-link"></span></a>what happens when you create a branch</h2>

<p>To the files, nothing.</p>

<p>To the tree, suppose we are [1u]</p>

<p>Then after:</p>

<pre><code>git branch b
</code></pre>

<p>It becomes:</p>

<pre><code>(1)
 |
 master *
 b
</code></pre>

<h2>
<a name="what-happens-to-a-branch-when-you-commit" class="anchor" href="#what-happens-to-a-branch-when-you-commit"><span class="octicon octicon-link"></span></a>what happens to a branch when you commit</h2>

<p>The <em>current</em> branch moves forward and continues being current.</p>

<p>Ex: start at [1ub] now:</p>

<pre><code>git add c
git commit -am 'c'
</code></pre>

<p>Gives:</p>

<pre><code>(1)-----(c)
         |
         master *
</code></pre>

<p>Now try:</p>

<pre><code>git checkout b
</code></pre>

<p>Which gives:</p>

<pre><code>(1)-----(2)
 |       |
 b *     master
</code></pre>

<p>C disappears because it was not tracked in b:</p>

<pre><code>ls
    #a b
echo c1 &gt; c
git add c
git commit -m 'cb'
</code></pre>

<p>And now we have:</p>

<pre><code>+---------------(cb)
|                |
</code></pre>

<p>(1)-----(2)       b *
            |
            master</p>

<p>Which makes it obvious why a branch is called a branch.</p>

<h2>
<a name="detached-head" class="anchor" href="#detached-head"><span class="octicon octicon-link"></span></a>detached head</h2>

<p>Is when you checkout to a commit that has no branch associated.</p>

<p>Ex: start with [2]</p>

<pre><code>git checkout HEAD^
</code></pre>

<p>Now see:</p>

<pre><code>git branch
</code></pre>

<p>Shows current branch as:</p>

<pre><code>(no branch) *
</code></pre>

<h3>
<a name="what-should-i-do-if-i-want-to-branch-from-the-detached-head" class="anchor" href="#what-should-i-do-if-i-want-to-branch-from-the-detached-head"><span class="octicon octicon-link"></span></a>what should I do if I want to branch from the detached head</h3>

<p>If you are on it, you should first create a branch:</p>

<pre><code>git branch b
</code></pre>

<p>Then work normally.</p>

<p>You can also create a branch before going to it with:</p>

<pre><code>git branch &lt;hash&gt;
</code></pre>

<h3>
<a name="what-happens-if-i-commit-on-a-detached-head" class="anchor" href="#what-happens-if-i-commit-on-a-detached-head"><span class="octicon octicon-link"></span></a>what happens if I commit on a detached head</h3>

<p>Bad things! never do this!</p>

<p>Git does commit, but stays on a undefined state.</p>

<p>To correct it you can create a branch:</p>

<pre><code>git branch b
</code></pre>

<p>And since you were on no branch, git automatically changes to <code>b</code>.</p>

<h4>
<a name="what-if-i-commit-and-checkout" class="anchor" href="#what-if-i-commit-and-checkout"><span class="octicon octicon-link"></span></a>what if I commit and checkout??</h4>

<p>Worse things.</p>

<p>Your old commit still exists, but does not show even on <code>git log --all</code>.</p>

<p>Git warns you: this might be a good time to give it a branch, and you should as:</p>

<pre><code>git branch b hash
</code></pre>

<h2>
<a name="start-point" class="anchor" href="#start-point"><span class="octicon octicon-link"></span></a>start point</h2>

<p>You can also create a branch at any commit other than the current one:</p>

<p>Take [2]</p>

<pre><code>git branch b HEAD~
</code></pre>

<p>Now</p>

<pre><code>git branch -v
</code></pre>

<p>To create switch to it directly:</p>

<pre><code>git checkout -b b HEAD~
</code></pre>

<h2>
<a name="slash-in-branch-name" class="anchor" href="#slash-in-branch-name"><span class="octicon octicon-link"></span></a>slash in branch name</h2>

<p>Inside the <code>.git</code>, branches are placed under <code>refs</code>.</p>

<p>If you name a branch <code>a/b</code> it will create a file under <code>refs/a/b</code>.</p>

<p>Therefore you can't both:</p>

<ul>
<li>have a branch named <code>a</code>
</li>
<li>have a branch names <code>a/b</code>
</li>
</ul><p>since <code>a</code> would have to be both a directory and a file at the same time for that to work.</p>

<h2>
<a name="rename-a-branch" class="anchor" href="#rename-a-branch"><span class="octicon octicon-link"></span></a>rename a branch</h2>

<p>Rename a given branch:</p>

<pre><code>git branch -m oldname newname
</code></pre>

<p>Rename the current branch:</p>

<pre><code>git branch -m newname
</code></pre>

<h1>
<a name="checkout" class="anchor" href="#checkout"><span class="octicon octicon-link"></span></a>checkout</h1>

<p>Goes to another version</p>

<p>Before you go to another version, you must see which versions you can go back with [log] or [gitk].</p>

<h2>
<a name="entire-repo" class="anchor" href="#entire-repo"><span class="octicon octicon-link"></span></a>entire repo</h2>

<p>Use the <code>checkout</code> command with some version name as explained in [how to refer to a version] for example:</p>

<pre><code>git checkout 494b
git checkout HEAD~
git checkout master~
</code></pre>

<p>The command is called <code>checkout</code>, because we are goint to "check out" what another version was like.</p>

<p>If you checkout the entire repo, <code>HEAD</code> moves!</p>

<p>If you ommit the version, defaults to <code>HEAD</code> so:</p>

<pre><code>git checkout
git checkout HEAD
</code></pre>

<p>Are the same.</p>

<h3>
<a name="example-checkout-entire-repo" class="anchor" href="#example-checkout-entire-repo"><span class="octicon octicon-link"></span></a>example: checkout entire repo</h3>

<p>Start with [3].</p>

<p>It looks like this:</p>

<pre><code>(1)-----(2)-----(3)
                 |
                 master
                 HEAD
</code></pre>

<p>Now do:</p>

<pre><code>git checkout HEAD~~
</code></pre>

<p>The files <code>a</code> and <code>b</code> now both contain one line!</p>

<pre><code>cat a
    #a1

cat b
    #b1
</code></pre>

<p>The tree looks like this:</p>

<pre><code>(1)-----(2)-----(3)
 |               |
 HEAD            master
</code></pre>

<p>Note how the <code>HEAD</code> moved, but <code>master</code> did not!</p>

<p>Now do:</p>

<pre><code>git checkout master
</code></pre>

<p>And <code>a</code> and <code>b</code> contain three lines again. This is how things look:</p>

<pre><code>(1)-----(2)-----(3)
                 |
                 master
                 HEAD

cat a
    #a1

cat b
    #b1
</code></pre>

<p>Files that are not tracked stay the same.</p>

<h3>
<a name="example-untracked-files" class="anchor" href="#example-untracked-files"><span class="octicon octicon-link"></span></a>example: untracked files</h3>

<p>Start with [2]</p>

<pre><code>echo -e 'c1\nc2' &gt; c
</code></pre>

<p>Now checkout:</p>

<pre><code>git checkout HEAD~
</code></pre>

<p><code>a</code> and <code>b</code> have changed</p>

<pre><code>cat a
    #a1

cat b
    #b1
</code></pre>

<p>But the untracked <code>c</code> stays the same:</p>

<pre><code>cat c
    #c1
    #c2
</code></pre>

<h3>
<a name="uncommited-changes" class="anchor" href="#uncommited-changes"><span class="octicon octicon-link"></span></a>uncommited changes</h3>

<p>If you have not yet commited changes, git warns you and does not checkout.</p>

<h4>
<a name="example-checkout-uncommited-modification" class="anchor" href="#example-checkout-uncommited-modification"><span class="octicon octicon-link"></span></a>example: checkout uncommited modification</h4>

<p>Start with [2].</p>

<pre><code>echo a3 &gt;&gt; a
</code></pre>

<p>Then try:</p>

<pre><code>git checkout HEAD~
</code></pre>

<p>Git says that there is a change, and does nothing.</p>

<h4>
<a name="example-checkout-file-overwite" class="anchor" href="#example-checkout-file-overwite"><span class="octicon octicon-link"></span></a>example: checkout file overwite</h4>

<p>Start with [2]</p>

<pre><code>git rm a
git commit -am '-a'

git echo -e 'a1\na2' &gt; a
</code></pre>

<p>Then try:</p>

<pre><code>git checkout HEAD~~
</code></pre>

<p>This fails again, because file a would be overwritten, even if its contents did not change.</p>

<h2>
<a name="single-file-or-dir" class="anchor" href="#single-file-or-dir"><span class="octicon octicon-link"></span></a>single file or dir</h2>

<p>Just like checking out the dir, but you also specify the files:</p>

<pre><code>git checkout HEAD~ a b
</code></pre>

<p>The head does not move now! this is different from the behaviour of checkout [entire repo]</p>

<p>New files that appear are just like untracked ones.</p>

<h3>
<a name="example-checkout-single-file" class="anchor" href="#example-checkout-single-file"><span class="octicon octicon-link"></span></a>example: checkout single file</h3>

<p>Start from [2]</p>

<pre><code>git checkout HEAD^ a

cat a
    #a1
</code></pre>

<p>But we are still at master:</p>

<pre><code>git branch
    #* master
</code></pre>

<h3>
<a name="example-checkout-single-removed-file" class="anchor" href="#example-checkout-single-removed-file"><span class="octicon octicon-link"></span></a>example: checkout single removed file</h3>

<p>Start from [2]</p>

<p>Remove b and commit:</p>

<pre><code>git rm b
git commit -am '-b'
</code></pre>

<p>Now restore it:</p>

<pre><code>git checkout HEAD~ b

cat b
    #b1
    #b2
</code></pre>

<p>The file must exist in the version you want to checkout to.</p>

<h3>
<a name="counter-example-checkout-after-remove" class="anchor" href="#counter-example-checkout-after-remove"><span class="octicon octicon-link"></span></a>counter-example: checkout after remove</h3>

<pre><code>start with [1]

git rm a
git commit -am 'noa`
</code></pre>

<p>No try:</p>

<pre><code>git checkout a
</code></pre>

<p>Which is the same as:</p>

<pre><code>git checkout HEAD -- a
</code></pre>

<p>And it fails, because in <code>HEAD</code> a was removed from the repo.</p>

<h3>
<a name="uncommited-changes-1" class="anchor" href="#uncommited-changes-1"><span class="octicon octicon-link"></span></a>uncommited changes</h3>

<p>Unlike when cheking out the entire repo, Git does not prompt you in case of non committed modifications When checking out individual files!</p>

<p>This is a great way to achieve data loss.</p>

<h3>
<a name="example-checkout-single-file-with-modifications" class="anchor" href="#example-checkout-single-file-with-modifications"><span class="octicon octicon-link"></span></a>example: checkout single file with modifications</h3>

<p>Start from [2]</p>

<pre><code>echo a3 &gt;&gt; a
git checkout
</code></pre>

<h1>
<a name="stash" class="anchor" href="#stash"><span class="octicon octicon-link"></span></a>stash</h1>

<p>Saves all modifications which are not on the index and returns the working tree to <code>HEAD</code> into a modification stack called <em>stash</em>.</p>

<p>The changes can be applied to any branch afterwards.</p>

<p>Push changes to the top of the stash:</p>

<pre><code>git stash
</code></pre>

<p>List stash:</p>

<pre><code>git stash list
</code></pre>

<p>Apply change at the top of the stash:</p>

<pre><code>git stash apply
</code></pre>

<h1>
<a name="merge" class="anchor" href="#merge"><span class="octicon octicon-link"></span></a>merge</h1>

<p>Is when you take two branches and make a new one that is child of both.</p>

<p>There are certain mereges that are made automatcially:</p>

<ul>
<li>file added</li>
<li>different lines of a file modified</li>
</ul><p>If all merges can be done automatically, then you are prompted for a commit message the current head advances automatically to a new commit. This process is called fast forward.</p>

<p>However there changes that cannot be merged automatically such as modification of a single line on both versions.</p>

<p>If that happens, and the file is not a binray file, the file on the tree be modified to contain:</p>

<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
    config.password_length = 1..128
=======
    config.password_length = 8..128
&gt;&gt;&gt;&gt;&gt;&gt;&gt; other-branch
</code></pre>

<p>and if you do <code>git status</code> you will see:</p>

<pre><code>both modified: filename
</code></pre>

<p>To finish the merge you should check all of the both modified files, correct them, <code>git add</code> and then <code>git commit</code>.</p>

<p>To put the file into one of the two versions, you can do either:</p>

<pre><code>git checkout --ours filename
git checkout --theirs filename
</code></pre>

<p>This is the most common solution for binary file conflicts.</p>

<p>To go back to the merge conflict version with <code>&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> you can do:</p>

<pre><code>git checkout -m filename
</code></pre>

<p>This is what you do when you like the modifications of two branches!</p>

<h2>
<a name="strategies" class="anchor" href="#strategies"><span class="octicon octicon-link"></span></a>strategies</h2>

<p>Git attempts to merge automatically using one of different merge strategies.</p>

<p>Some strategies may require user intervention, while others never do.</p>

<p>Some important strategies are:</p>

<ul>
<li>
<p>ours: keeps local changes</p>

<pre><code>git merge -s ours ref
</code></pre>
</li>
<li>
<p>theirs: keeps remote changes. Must be used with <code>-X</code> instead of <code>-s</code>, as discussed <a href="http://stackoverflow.com/questions/173919/git-merge-s-ours-what-about-theirs">here</a></p>

<pre><code>git merge -X theirs ref
</code></pre>
</li>
</ul><h2>
<a name="ignore-certain-files-on-merge" class="anchor" href="#ignore-certain-files-on-merge"><span class="octicon octicon-link"></span></a>ignore certain files on merge</h2>

<p>Run:</p>

<pre><code>`git config merge.ours.driver true`
</code></pre>

<p>and use a <code>.gitattributes</code> as:</p>

<pre><code>file_to_ignore merge=ours
</code></pre>

<h1>
<a name="push" class="anchor" href="#push"><span class="octicon octicon-link"></span></a>push</h1>

<p>Makes changes on a [bare] remote repo.</p>

<p>The other repo can be on an external server like Github, or on your local filesystem.</p>

<p>Typical changes possible with push:</p>

<ul>
<li>put branches there</li>
<li>remove branches from there</li>
</ul><p>Push current branch to <code>remote</code> bare repo over branch <code>branch</code>:</p>

<pre><code>git push remote branch
</code></pre>

<p>where <code>remote</code> is anything that identifies the remote such as its url or name given by <code>add</code>.</p>

<p>If the remote branch does not exist it is created.</p>

<h3>
<a name="-u" class="anchor" href="#-u"><span class="octicon octicon-link"></span></a>-u</h3>

<p>Each local branch can have a remote branch which it tracks, which is known as the upstream or tracked branch.</p>

<p>Push and also set the upstream of current branch:</p>

<pre><code>git push -u remote branch
</code></pre>

<p>Set the upstream without push:</p>

<pre><code>git branch --set-upstream remote branch
</code></pre>

<p>There seems to be no clean way to get the corresponding upstreams of all branches: <a href="http://stackoverflow.com/questions/4950725/how-do-i-get-git-to-show-me-which-branches-are-tracking-what">http://stackoverflow.com/questions/4950725/how-do-i-get-git-to-show-me-which-branches-are-tracking-what</a></p>

<p>The best options are:</p>

<p>Interactive for a single branch:</p>

<pre><code>git branch -vv
</code></pre>

<p>Interactive for all branches:</p>

<pre><code>vim .git/config
</code></pre>

<p>For scripts for a single branch:</p>

<pre><code>git rev-parse --abbrev-ref master@{upstream}
</code></pre>

<p>Push current branch to its default upstream (remote/branch) pair</p>

<pre><code>git push -u git@github.com:userid/reponame.git master
</code></pre>

<p>What happens when you do:</p>

<pre><code>git push
</code></pre>

<p>depends on the <code>push.default</code> option: <a href="http://stackoverflow.com/questions/948354/git-push-default-behavior">http://stackoverflow.com/questions/948354/git-push-default-behavior</a></p>

<p>The default as of 1.8 is <code>simple</code>, which pushes to upstream only if the upstream branch name is the same as the current branch.</p>

<p>Push all local branches which track a remote at <code>remote</code>:</p>

<pre><code>git push remote
</code></pre>

<h2>
<a name="push--f" class="anchor" href="#push--f"><span class="octicon octicon-link"></span></a>push -f</h2>

<p>Push to remote branch even if the remote branch is not a descendant of the local branch.</p>

<p>I think this:</p>

<ul>
<li>finds the closest common ancestor of the remote</li>
<li>makes everything that comes after a [dangling commit]</li>
<li>mounts the local changes on the command ancestor</li>
</ul><p>May lead to data loss.</p>

<p>Example:</p>

<pre><code>./clone.sh multi
cd a
git reset --hard HEAD~
git push
    #does not work
git push -f
    #works
git cd ../ao
git log --pretty=oneline
    #we're on 1
git fsck --lost-found
    #one dangling commit
</code></pre>

<hr><p>Push all branches:</p>

<pre><code>git push origin --all
</code></pre>

<p>It is possible to push the current branch by using:</p>

<pre><code>git config push.default current
</code></pre>

<h2>
<a name="delete-remote-branch" class="anchor" href="#delete-remote-branch"><span class="octicon octicon-link"></span></a>delete remote branch</h2>

<pre><code>git push origin --delete branch
</code></pre>

<h1>
<a name="remote" class="anchor" href="#remote"><span class="octicon octicon-link"></span></a>remote</h1>

<p>Manage remote repositories.</p>

<p>When you clone something, it alreay has a remote called <code>origin</code>.</p>

<h2>
<a name="view-remote" class="anchor" href="#view-remote"><span class="octicon octicon-link"></span></a>view remote</h2>

<p>Shows remote repo aliases without their real addresses:</p>

<pre><code>git remote
</code></pre>

<p>Shows remote repo aliases and their real addresses:</p>

<pre><code>git remote -v
</code></pre>

<p>View detail of branch:</p>

<pre><code>git remote show $B
</code></pre>

<h2>
<a name="remote-add" class="anchor" href="#remote-add"><span class="octicon octicon-link"></span></a>remote add</h2>

<p>One way to avoid typing the repo url is giving it an alias with <code>remote add</code>:</p>

<pre><code>git remote add origin git@github.com:userid/reponame.git
</code></pre>

<p>Origin can be any alias we want, but <code>origin</code> is a standard name for the main remote repo.</p>

<p>And now you can do:</p>

<pre><code>git push origin master
</code></pre>

<p>You can view existing aliases with:</p>

<pre><code>git remote -v
</code></pre>

<p>Which gives:</p>

<pre><code>origin  git@github.com:cirosantilli/reponame.git (fetch)
origin  git@github.com:cirosantilli/reponame.git (push)
</code></pre>

<h2>
<a name="modify-remote" class="anchor" href="#modify-remote"><span class="octicon octicon-link"></span></a>modify remote</h2>

<p>Remove the remote branch called github:</p>

<pre><code>git remote rm github
</code></pre>

<p>Change the address of a remote:</p>

<pre><code>git remote set-url git://github.com/username/projectname.git
</code></pre>

<h1>
<a name="remote-head" class="anchor" href="#remote-head"><span class="octicon octicon-link"></span></a>remote head</h1>

<p>Is a head that has a name.</p>

<p>It is not a branch however!</p>

<p>If you checkout to them, you are in a detached head state.</p>

<h2>
<a name="how-to-get-one" class="anchor" href="#how-to-get-one"><span class="octicon octicon-link"></span></a>how to get one</h2>

<p>See [clone] and [fetch].</p>

<h2>
<a name="view-remote-branches" class="anchor" href="#view-remote-branches"><span class="octicon octicon-link"></span></a>view remote branches</h2>

<p>First fetch the branches with:</p>

<pre><code>git fetch remote
</code></pre>

<p>View only remote branches, not local ones:</p>

<pre><code>git branch -r
</code></pre>

<p>View all branches, local and remote:</p>

<pre><code>git branch -a
</code></pre>

<p>They are listed like <code>remote/\&lt;remote-name&gt;/\&lt;branch-name&gt;</code></p>

<p>Where remote-name was either given:</p>

<ul>
<li>explicitly by <code>remote add</code>
</li>
<li>
<code>origin</code> by default by <code>clone</code>
</li>
</ul><h2>
<a name="how-to-refer-to-one" class="anchor" href="#how-to-refer-to-one"><span class="octicon octicon-link"></span></a>how to refer to one</h2>

<p>Depends on the command.</p>

<p>The best way is explicitly / but some commands do explicit stuff if you enter just  and there is no other branch in your repo with that name.</p>

<p>Ex: <code>origin/master</code>, <code>origin/feature2</code>, <code>upstream/feature2</code>, etc.</p>

<h3>
<a name="branch-1" class="anchor" href="#branch-1"><span class="octicon octicon-link"></span></a>branch</h3>

<p>Branch only sees remotes if you give the <code>remote-name</code> explicitly.</p>

<h3>
<a name="checkout-1" class="anchor" href="#checkout-1"><span class="octicon octicon-link"></span></a>checkout</h3>

<p>If you have a remote <code>origin/b</code> and no branch named <code>b</code>,</p>

<pre><code>git checkout b
</code></pre>

<p>Is the same as (magic!, never do this, it is very confuging!):</p>

<pre><code>git checkout b origin/b
</code></pre>

<p>But:</p>

<pre><code>git checkout -b b
</code></pre>

<p>Is the same as:</p>

<pre><code>git branch b
git checkout b
</code></pre>

<p>If you had a branch named <code>b</code>:</p>

<pre><code>git checkout b
</code></pre>

<p>Would simply go to it.</p>

<h1>
<a name="urls" class="anchor" href="#urls"><span class="octicon octicon-link"></span></a>urls</h1>

<p>See protocols.</p>

<h1>
<a name="protocols" class="anchor" href="#protocols"><span class="octicon octicon-link"></span></a>protocols</h1>

<p>If you can connect via SSH to a computer as:</p>

<pre><code>ssh username@host
</code></pre>

<p>then you can do git operations as:</p>

<pre><code>git username@host:/path/to/repo
</code></pre>

<p>Github git repo directories always end in <code>.git</code>, but this is just a convention. Also, in Github there is a single git user called git.</p>

<p>Other methods of connection include:</p>

<ul>
<li>HTTP over urls of type <code>http://</code>. Less efficient than the git protocol.</li>
<li>a git specific protocol with id <code>git://</code>. More efficient than HTTP since git specific,
but also requires a more specialized server.</li>
</ul><h1>
<a name="clone" class="anchor" href="#clone"><span class="octicon octicon-link"></span></a>clone</h1>

<p>Make a "copy" of another repo.</p>

<p>Fetchs all the remote branches.</p>

<p>Creates only a single branch: the branch were the <code>HEAD</code> of the remote was.</p>

<h2>
<a name="example-clone-and-branches" class="anchor" href="#example-clone-and-branches"><span class="octicon octicon-link"></span></a>example: clone and branches</h2>

<p>Start with [multi].</p>

<pre><code>git clone a c
</code></pre>

<p>Creates a repo c that is a "copy" of a. now:</p>

<pre><code>cd c
branch -a
    #master *
    #remote/origin/b
    #remote/origin/b2
    #remote/origin/master
</code></pre>

<p>So you only have one branch, and the other are [remote head]s.</p>

<p>But if you do:</p>

<pre><code>cd a
git checkout b
cd ..
git clone a d
cd d
git branch -a
    #b *
    #origin/b
    #origin/b2
    #origin/master
</code></pre>

<p>Then you have a <code>b</code> branch, because that is where the head was when you cloned.</p>

<h2>
<a name="from-github" class="anchor" href="#from-github"><span class="octicon octicon-link"></span></a>from github</h2>

<p>It can also clone from a server such as github:</p>

<pre><code>git clone git@github.com:userid/reponame.git newname
</code></pre>

<p>This is how you download a project which interests you.</p>

<h1>
<a name="fetch" class="anchor" href="#fetch"><span class="octicon octicon-link"></span></a>fetch</h1>

<p>Looks for all modifications made on all branches of a remote and make them available on repo through [remote head]s.</p>

<p>Does not modify any branch on current repo.</p>

<p>The remote must have a name (either given automatically at <code>clone</code> as <code>origin</code> or through explicit <code>remote add</code>).</p>

<h2>
<a name="example" class="anchor" href="#example"><span class="octicon octicon-link"></span></a>example</h2>

<p>State of the remote:</p>

<pre><code>(A)----(B)----(C)----(H)
               |      |
               |      master *
               |
               +-----(E)
                      |
                      feature
</code></pre>

<p>Local repo after a clone:</p>

<pre><code>git clone path/to/repo

(A)----(B)----(C)----(D)
               |      |
               |      master *
               |      origin/master
               |
               +-----(E)
                      |
                      origin/feature
</code></pre>

<p>New state of the remote:</p>

<pre><code>(A)----(B)----(C)----(D)----(H)
               |             |
               |             master *
               |
               +-----(E)----(F)--------(G)
                                        |
                                        feature
</code></pre>

<p>Local repo after a fetch:</p>

<pre><code>git fetch origin

(A)----(B)----(C)----(D)--------(H)
               |      |          |
               |      master *   origin/master
               |
               +-----(E)--------(F)--------(G)
                      |                     |
                      feature               origin/feature
</code></pre>

<h2>
<a name="remove-a-pushed-remote-branch" class="anchor" href="#remove-a-pushed-remote-branch"><span class="octicon octicon-link"></span></a>remove a pushed remote branch</h2>

<p>If you pushed a branch test by mistake, here is how you remove it:</p>

<pre><code>git push origin :branchname
</code></pre>

<p>Just add the colon before the branch name.</p>

<h1>
<a name="bare" class="anchor" href="#bare"><span class="octicon octicon-link"></span></a>bare</h1>

<p>A repo that only contains the files that are inside <code>.git</code>.</p>

<p>This is what github stores for you: no need to store the files also!</p>

<p>There are some operations that you can only do/cannot do on a bare repo:</p>

<ul>
<li>
<p>you can only push to a bare repo.</p>

<p>This means that using git to deploy a project requires a bare repository on the server + a post commit hook that will update the tree where desired.</p>
</li>
<li><p>you cannot pull from a bare repo.</p></li>
</ul><p>To create a bare repo from scratch:</p>

<pre><code>git init --bare
</code></pre>

<p>To create a bare repo that is a clone of another repo:</p>

<pre><code>git clone --bare other
</code></pre>

<h1>
<a name="pull" class="anchor" href="#pull"><span class="octicon octicon-link"></span></a>pull</h1>

<p>Pull is exactly the same as [fetch] + [merge] on given branch and merges with current branch.</p>

<p>Does not update remote heads like [fetch] does.</p>

<h2>
<a name="example-pull" class="anchor" href="#example-pull"><span class="octicon octicon-link"></span></a>example: pull</h2>

<p>State of the remote:</p>

<pre><code>(A)----(B)----(C)----(H)
               |      |
               |      master *
               |
               +-----(E)
                      |
                      feature
</code></pre>

<p>Your repo after a clone:</p>

<pre><code>git clone path/to/repo

(A)----(B)----(C)----(D)
               |      |
               |      master *
               |      origin/master
               |
               +-----(E)
                      |
                      origin/feature
</code></pre>

<p>New state of the remote:</p>

<pre><code>(A)----(B)----(C)----(D)----(H)
               |             |
               |             master *
               |
               +-----(E)----(F)--------(G)
                                        |
                                        feature
</code></pre>

<p>Local repo after a <code>merge</code>:</p>

<pre><code>git pull origin master

(A)----(B)----(C)----(D)--------(H)
               |                 |
               |                 master *
               |                 origin/master
               |
               +-----(E)--------(F)--------(G)
                      |                     |
                      feature               origin/feature
</code></pre>

<p>So you current branch <code>master</code> has been merged into the branch <code>master</code> from repo <code>origin</code>.</p>

<h1>
<a name="push-to-github" class="anchor" href="#push-to-github"><span class="octicon octicon-link"></span></a>push to github</h1>

<p>To upload you must have an account on some server and you must have created.</p>

<p>Here we show how to upload to <a href="https://github.com/">github</a>.</p>

<h2>
<a name="github-setup" class="anchor" href="#github-setup"><span class="octicon octicon-link"></span></a>github setup</h2>

<p>Create an account. your userid is: <code>userid</code></p>

<p>Create a repository. call it <code>reponame</code></p>

<p>Don't initilized it with a readme.</p>

<p>The git url is then <code>git@github.com:userid/reponame.git</code></p>

<h2>
<a name="do-the-upload" class="anchor" href="#do-the-upload"><span class="octicon octicon-link"></span></a>do the upload</h2>

<p>Upload the latest version to the server with:</p>

<pre><code>git push git@github.com:userid/reponame.git master
</code></pre>

<p>This may ask for you github username and pass.</p>

<p>Go back to github and browse your uploaded files to check that they are there.</p>

<h2>
<a name="github-and-tags" class="anchor" href="#github-and-tags"><span class="octicon octicon-link"></span></a>github and tags</h2>

<p>If you tag then you can refer have raw urls for tags.</p>

<h1>
<a name="file-permissions" class="anchor" href="#file-permissions"><span class="octicon octicon-link"></span></a>file permissions</h1>

<p>Git keeps file permissions (rwx) as metadata inside the <code>.git</code> dir.</p>

<h1>
<a name="empty-dirs" class="anchor" href="#empty-dirs"><span class="octicon octicon-link"></span></a>empty dirs</h1>

<p>Git ignores empty dirs.</p>

<p>To force git to keep a dir, add a file to it.</p>

<p>Popular possibilities are:</p>

<ul>
<li><p><code>readme</code> file explaining why the dir is there after all!</p></li>
<li><p><code>.gitkeep</code> file. It has absolutelly no special meaning for git, but is somewhat conventional.</p></li>
</ul><h1>
<a name="symlinks" class="anchor" href="#symlinks"><span class="octicon octicon-link"></span></a>symlinks</h1>

<h2>
<a name="on-push" class="anchor" href="#on-push"><span class="octicon octicon-link"></span></a>on push</h2>

<p>Git stores symlinks as files containing the link location + some metadata inside <code>.git</code> that indicates that it is a symlink.</p>

<h2>
<a name="on-pull" class="anchor" href="#on-pull"><span class="octicon octicon-link"></span></a>on pull</h2>

<p>Git recreates the symlinks on local system.</p>

<p>Start with [multi].</p>

<pre><code>cd a
ln -s a c
git add c
git commit -am 'c'
git push

cd ..
git clone ao c
cd c
[ -s c ] &amp;&amp; echo ok
</code></pre>

<h1>
<a name="submodules" class="anchor" href="#submodules"><span class="octicon octicon-link"></span></a>submodules</h1>

<p>Git commands inside the submodule work just like git commands on a regular git repo!</p>

<h2>
<a name="application" class="anchor" href="#application"><span class="octicon octicon-link"></span></a>application</h2>

<p>You have 3 repos.</p>

<p>You want to use files from a certain versions of repo 1 in repos 2 and 3.</p>

<p>There is no reliable way to:</p>

<ul>
<li>share a file between programs ( like <code>PATH</code> does for executable )</li>
<li>maintain different versions of a program ( like <code>virtualenv</code> does for python )</li>
</ul><p>So you have to keep a copy of the shared repo for each using repo anyways.</p>

<h2>
<a name="creation" class="anchor" href="#creation"><span class="octicon octicon-link"></span></a>creation</h2>

<p>You have a latex <code>a.sty</code> file which you want to use.</p>

<ul>
<li>on version <code>1.1</code> for a latex project 2 in <code>project2</code> repo</li>
<li>on version <code>1.0</code> for a latex project 3 in <code>project3</code> repo</li>
</ul><p>Make a repo and put <code>a.sty</code> in the repo. Call it <code>latex</code>.</p>

<p>On project 2:</p>

<pre><code>git submodule add git://github.com/USERNAME/latex.git shared
ln -s shared/a.sty a.sty
git add .gitmodules
</code></pre>

<p>Now a dir callled <code>shared</code> was created and contains your repo.</p>

<p>Don't ever touch that dir directly. Changes in that dir are not seen by git.</p>

<h2>
<a name="clone-a-repo-that-contains-a-submodule" class="anchor" href="#clone-a-repo-that-contains-a-submodule"><span class="octicon octicon-link"></span></a>clone a repo that contains a submodule</h2>

<p>To get all the files of submodules you need the <code>--recursive</code> flag:</p>

<pre><code>git clone --recursive git://github.com/USERNAME/project2.git
</code></pre>

<p>If you forgot to use recursive when you cloned, you should:</p>

<pre><code>git submodule update --init
</code></pre>

<p>It seems that making clone recursive by default is neither possible nor a good idea: <a href="http://stackoverflow.com/questions/4251940/retrospectively-add-recursive-to-a-git-repo">http://stackoverflow.com/questions/4251940/retrospectively-add-recursive-to-a-git-repo</a></p>

<h2>
<a name="update-the-content-of-a-submodule" class="anchor" href="#update-the-content-of-a-submodule"><span class="octicon octicon-link"></span></a>update the content of a submodule</h2>

<pre><code>cd share
git pull
</code></pre>

<p>Now we have:</p>

<pre><code>git status
    #modified:   shared (new commits)
</code></pre>

<p>For your repo to incorporate this update, you have to add the submodule path (<code>share/</code>) and commit, or simply do a <code>commit -a</code> next time.</p>

<p>From the outside, the submodule looks much like a regular git controlled file.</p>

<p>Update the contents of all submodules:</p>

<pre><code>git submodule foreach git pull
</code></pre>

<p>This does not work if the modules are only listed under <code>.gitmodule</code> but have not been added to index with <code>add</code>.</p>

<h2>
<a name="foreach" class="anchor" href="#foreach"><span class="octicon octicon-link"></span></a>foreach</h2>

<p>Do an arbritary command from each submodule directory.</p>

<p>Ex: updates all submodules:</p>

<pre><code>git submodule foreach git pull
</code></pre>

<p>Print full paths of each submodule:</p>

<pre><code>git submodule foreach pwd
</code></pre>

<h2>
<a name="go-back-to-another-version-of-a-submodule" class="anchor" href="#go-back-to-another-version-of-a-submodule"><span class="octicon octicon-link"></span></a>go back to another version of a submodule</h2>

<pre><code>cd share
git log
git checkout VERSION-ID
</code></pre>

<h2>
<a name="remove-a-submodule" class="anchor" href="#remove-a-submodule"><span class="octicon octicon-link"></span></a>remove a submodule</h2>

<p>TODO test this</p>

<p>Remove it from the <code>.gitmodules</code> file:</p>

<pre><code>vim .submodules
</code></pre>

<p>Remove it from <code>.git/config</code>:</p>

<pre><code>vim .git/config
rm --cached $path_to_submodule #(no trailing slash).
rm -Rf .git/modules/$path_to_submodule
git commit -am 'removed submodule'
rm -rf $path_to_submodule
</code></pre>

<p>Of course, this is horrible, and it seems that as of git 1.8.3 there will be a <code>git deinit</code> command! TODO remove when true</p>

<h2>
<a name="change-submodule-upstream" class="anchor" href="#change-submodule-upstream"><span class="octicon octicon-link"></span></a>change submodule upstream</h2>

<p>Edit <code>.gitmodules</code> to the correct upstream</p>

<pre><code>git submodule sync
git submodule update
</code></pre>

<h2>
<a name="change-submodule-location" class="anchor" href="#change-submodule-location"><span class="octicon octicon-link"></span></a>change submodule location</h2>

<p><a href="http://stackoverflow.com/questions/4604486/how-do-i-move-an-existing-git-submodule-within-a-git-repository">http://stackoverflow.com/questions/4604486/how-do-i-move-an-existing-git-submodule-within-a-git-repository</a></p>

<h1>
<a name="rebase" class="anchor" href="#rebase"><span class="octicon octicon-link"></span></a>rebase</h1>

<p>Change local history making it appear linear thus clearer.</p>

<p>As any history change, should only be done before pushing to a remote.</p>

<h2>
<a name="non-interactive-rebase" class="anchor" href="#non-interactive-rebase"><span class="octicon octicon-link"></span></a>non interactive rebase</h2>

<p>Given:</p>

<pre><code>(A)----(B)----(C)
        |      |
        |      master *
        |
        +-----(D)
               |
               feature
</code></pre>

<p>If you do:</p>

<pre><code>git checkout feature
git rebase master
</code></pre>

<p>you get:</p>

<pre><code>(A)----(B)----(C)-------(D)
               |         |
               master    feature *
</code></pre>

<p>Therefore the rebase changes the history, making it look linear and therefore easier to understand.</p>

<p>This is how you should incorporate upstreams changes on your feature branch before you make a pull request, followed often by a squash interactive rebase.</p>

<h2>
<a name="interactive-rebase" class="anchor" href="#interactive-rebase"><span class="octicon octicon-link"></span></a>interactive rebase</h2>

<pre><code>git rebase -i HEAD~3
</code></pre>

<p>Opens up a vim buffer where you can modify the all commits between <code>HEAD</code> and <code>HEAD~2</code> (total 3 commits).</p>

<p>The buffer should contain something like this:</p>

<pre><code>pick fc95d59 last - 2 commit message
pick 81961e9 last - 1 commit message
pick d13a071 last commit message

# Rebase d57a363..d13a071 onto d57a363
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
</code></pre>

<h3>
<a name="edit" class="anchor" href="#edit"><span class="octicon octicon-link"></span></a>edit</h3>

<p><code>edit</code> can be used for example if we want to change a the commit message for <code>HEAD~</code> we edit that to:</p>

<pre><code>pick fc95d59 last - 2 commit message
edit 81961e9 last - 1 commit message
pick d13a071 last commit message
</code></pre>

<p>save and quit.</p>

<p>Now git puts us back as <code>HEAD~1</code>.</p>

<p>We can then:</p>

<pre><code>git commit --amend -m 'new last - 1 commit message'
</code></pre>

<p>When you are stisfied:</p>

<pre><code>git rebase --continue
</code></pre>

<p>If you change your mind and think that it is better not to rebase do:</p>

<pre><code>git rebase --abort
</code></pre>

<p>If you change your mind only about a single <code>commit</code>, but still want to change the others to:</p>

<pre><code>git rebase --skip
</code></pre>

<p>And we are back to <code>HEAD</code>.</p>

<p>Now <code>git log --pretty=oneline -n3</code> gives:</p>

<pre><code>fc95d59[...] last - 2 commit message
81961e9[...] new last - 1 commit message
d13a071[...] last commit message
</code></pre>

<h3>
<a name="squash" class="anchor" href="#squash"><span class="octicon octicon-link"></span></a>squash</h3>

<p><code>squash</code> can be used if you want to remove all trace of a commit.</p>

<p><code>squash</code> is useful when you are developping a feature locally and you want to save progress at several points in case you want to go back.</p>

<p>When you are done, you can expose a single commit for the feature, which will be much more concise and useful to others (or at least people will konw that you can use <code>squash</code>).</p>

<p>You will also look much smarter, since it will seem that you did not make lots of trials before getting things right.</p>

<p>If we want to remove only the <code>HEAD~</code> from history we edit as:</p>

<pre><code>pick fc95d59 last - 2 commit message
squash 81961e9 last - 1 commit message
pick d13a071 last commit message
</code></pre>

<p>This will open up another vim buffer like:</p>

<pre><code># This is a combination of 2 commits.
# The first commit's message is:

last -2 commit message

# This is the 2nd commit message:

last -1 commit message

#[more comments]
</code></pre>

<p>Because commits <code>HEAD~</code> and <code>HEAD~2</code> will be turned into one, it is likelly that the new message will be neither of the two.</p>

<p>So, erase all non comment lines and do something like:</p>

<pre><code>last -1 and last -2 together
#[more comments]
</code></pre>

<p>Now <code>git log --pretty=oneline -n2</code> gives sometehing like</p>

<pre><code>fc95d59[...] last -1 and last -2 together
d13a071[...] last commit message
</code></pre>

<p>It is not possible to squash the last commit of a rebase:</p>

<pre><code>squash fc95d59 last - 2 commit message
pick 81961e9 last - 1 commit message
pick d13a071 last commit message
</code></pre>

<p>To do that, it would be necessary to do a <code>git rabase -i HEAD~4</code>, and <code>pick</code> <code>HEAD~4</code>:</p>

<pre><code>pick fc95d59 last - 2 commit message
squash fc95d59 last - 2 commit message
pick 81961e9 last - 1 commit message
pick d13a071 last commit message
</code></pre>

<h3>
<a name="reorder-and-delete" class="anchor" href="#reorder-and-delete"><span class="octicon octicon-link"></span></a>reorder and delete</h3>

<p>It is also possible to reorder and erase any commit on the commit list.</p>

<p>All you need to do is to change the line order or remove lines.</p>

<h1>
<a name="cherry-pick" class="anchor" href="#cherry-pick"><span class="octicon octicon-link"></span></a>cherry pick</h1>

<p>Merge only certain commits from another branch.</p>

<p>Merge only the last commit from the <code>other-branch</code> branch:</p>

<pre><code>git cherry-pick other-branch
</code></pre>

<h1>
<a name="rerere" class="anchor" href="#rerere"><span class="octicon octicon-link"></span></a>rerere</h1>

<p>TODO</p>

<h1>
<a name="hooks" class="anchor" href="#hooks"><span class="octicon octicon-link"></span></a>hooks</h1>

<p>Take an action whenever something happens (a commit for example).</p>

<p>Create a hook, just add an executable file with a known hook name under <code>.git/hooks/</code>.</p>

<p>This executable may receive command line arguments which git uses to pass useful info to the executable.</p>

<p>Example:</p>

<pre><code>cd .git/hooks/
echo '#!/usr/bin/env bash

echo abc' &gt; post-commit
chmod +x post-commit
</code></pre>

<p>Now whenever you commit, you will see: abc on the terminal!</p>

<p>See: <a href="http://git-scm.com/book/en/Customizing-Git-Git-Hooks">http://git-scm.com/book/en/Customizing-Git-Git-Hooks</a> for other hook names.</p>

<p>When hooks are executed on the remote they echo on the local shell as: <code>remote: &lt;stdout&gt;</code>.</p>

<h1>
<a name="git-rev-parse" class="anchor" href="#git-rev-parse"><span class="octicon octicon-link"></span></a>git rev-parse</h1>

<p>Some useful commands to automate Git.</p>

<p>Get full path of repo root:</p>

<pre><code>./copy.sh 1d
git rev-parse --show-toplevel
    #`pwd`
cd d
    #$(dirname $(pwd))
</code></pre>

<p>Get what you need to cd to go to top level:</p>

<pre><code>./copy.sh 1d
git rev-parse --show-cdup
    #
cd d
git rev-parse --show-cdup
    #../
</code></pre>

<p>Path to <code>.git</code> dir:</p>

<pre><code>git rev-parse --git-dir
</code></pre>

<h1>
<a name="config" class="anchor" href="#config"><span class="octicon octicon-link"></span></a>config</h1>

<p>Allows to get and set config data.</p>

<p>Main config files:</p>

<ul>
<li><p><code>~/.gitconfig</code>: for all repos on current computer. <code>--global</code> option</p></li>
<li><p><code>.git/config</code>: cur repo only.</p></li>
</ul><p>It is a cfg file of type:</p>

<pre><code>[group]
    a = b
    c = d
</code></pre>

<p>Corresponding command lines of type:</p>

<pre><code>group.a b
group.c d
</code></pre>

<h2>
<a name="commands" class="anchor" href="#commands"><span class="octicon octicon-link"></span></a>commands</h2>

<p>List all non default configs set in those files:</p>

<pre><code>git config -l
</code></pre>

<p>Get single value:</p>

<pre><code>git config --global --get user.name
</code></pre>

<p>Get multiple values:</p>

<pre><code>git config --global --get-all user.name user.email
</code></pre>

<h2>
<a name="most-important-fields" class="anchor" href="#most-important-fields"><span class="octicon octicon-link"></span></a>most important fields</h2>

<p>Usename and email on commits:</p>

<pre><code>git config --global user.name "Ciro Duran Santilli"
git config --global user.email "ciro@mail.com"
</code></pre>

<p>Remember HTTP/HTTPS passwords for 15 minutes:</p>

<pre><code>git config --global credential.helper cache
</code></pre>

<p>Remember HTTP/HTTPS passwords for given time:</p>

<pre><code>git config --global credential.helper "cache --timeout=3600"
</code></pre>

<p>Let git color terminal output by default (but not if it goes to pipes, or the color escape chars might break programs): </p>

<pre><code>git config --global color.ui auto
</code></pre>

<p>Pager to use: <code>core.pager</code>. <code>less</code> by default.</p>

<p>Editor to use for commit and tag messages: <code>core.editor</code></p>

<p>Deal well with windows loved cr lf newlines: <code>core.autocrlf</code></p>

<p>Path of a global <code>.gititnore</code> file for all projects: <code>core.excludesfile</code>.</p>

<p>Commit message template file path: <code>commit.template</code></p>

<h3>
<a name="alias" class="anchor" href="#alias"><span class="octicon octicon-link"></span></a>alias</h3>

<p>Alias:</p>

<pre><code>git config --global alias.st status
</code></pre>

<p>Now you can use the alias as:</p>

<pre><code>git st
</code></pre>

<p>You can also alias to shell commands:</p>

<pre><code>git config --global alias.pwd '!pwd'
</code></pre>

<p>And this works:</p>

<pre><code>git pwd
</code></pre>

<p>It is always executed at the repo root.</p>

<p>This allows for the very useful combom:</p>

<pre><code>git config --global alias.exec '!exec '
</code></pre>

<p>Allowing you to do any command at toplevel:</p>

<pre><code>git exec make
</code></pre>

<h1>
<a name="gitattributes" class="anchor" href="#gitattributes"><span class="octicon octicon-link"></span></a>gitattributes</h1>

<p>Gitattributes are configs that apply only to specific paths, not the entire repo.</p>

<p>It can be put:</p>

<ul>
<li>inside a <code>.gitattributes</code> file in the repo.</li>
<li>inside the <code>.git/info/attributes</code> file.</li>
</ul><p>Examples:</p>

<pre><code>*.md diff=word
</code></pre>

<p>Always ignore remote version of cetain files on merge run:</p>

<pre><code>`git config merge.ours.driver true`
</code></pre>

<p>and use a <code>.gitattributes</code> as:</p>

<pre><code>file_to_ignore merge=ours
</code></pre>

<h1>
<a name="github-api-v3-via-curl" class="anchor" href="#github-api-v3-via-curl"><span class="octicon octicon-link"></span></a>github api v3 via curl</h1>

<p>Github has an HTTP api, meaning you can do stuff on Github programatically such as listing, creating or removing repos.</p>

<p>Here we show how to use the <code>curl</code> command line utility to do it.</p>

<p>Vars:</p>

<pre><code>USER=user
REPO=repo
PASS=
</code></pre>

<h2>
<a name="get-repo-info" class="anchor" href="#get-repo-info"><span class="octicon octicon-link"></span></a>get repo info</h2>

<p>Lots of info:</p>

<pre><code>curl -i https://api.github.com/users/$USER/repos
</code></pre>

<h2>
<a name="create-git-repo" class="anchor" href="#create-git-repo"><span class="octicon octicon-link"></span></a>create git repo</h2>

<pre><code>USER=
REPO=
curl -u "$USER" https://api.github.com/user/repos -d '{"name":"'$REPO'"}'
</code></pre>

<p>Repo name is the very minimal you must set, but you could also set other params such as:</p>

<pre><code>curl -u "$USER" https://api.github.com/user/repos -d '{
   "name": "'"$REPO"'",
   "description": "This is your first repo",
   "homepage": "https://github.com",
   "private": false,
   "has_issues": true,
   "has_wiki": true,
   "has_downloads": true
}'
</code></pre>

<p>Its just JSON (remember, last item cannot end in a comma).</p>

<h2>
<a name="delete-repo" class="anchor" href="#delete-repo"><span class="octicon octicon-link"></span></a>delete repo</h2>

<pre><code>curl -u "$USER" -X DELETE https://api.github.com/repos/$USER/$REPO
</code></pre>

<p>Careful, it works!</p>

<p>TODO</p>

<h1>
<a name="test-repos" class="anchor" href="#test-repos"><span class="octicon octicon-link"></span></a>test repos</h1>

<p>Use those to test stuff.</p>

<p>They can be generated with the <code>generate-test-repos.sh</code> script</p>

<p>They are described here.</p>

<h2>
<a name="0" class="anchor" href="#0"><span class="octicon octicon-link"></span></a>0</h2>

<p>2 files uncommitted</p>

<pre><code>ls
    #a b
cat a
    #a1
cat b
    #b1
git status
    #untracked: a b
</code></pre>

<h2>
<a name="0du" class="anchor" href="#0du"><span class="octicon octicon-link"></span></a>0du</h2>

<p>Same as [0], but with an untracked subdir d:</p>

<pre><code>ls
    #a b d
ls d
    #a b
cat d/a
    #da
cat d/b
    #db

git status
    #untracked: a b d/
</code></pre>

<h2>
<a name="1" class="anchor" href="#1"><span class="octicon octicon-link"></span></a>1</h2>

<p>Same as [0], but commited.</p>

<pre><code>ls
    #a b
cat a
    #a1
cat b
    #b1
git status
    #no changes

(1)
 |
 master
</code></pre>

<h2>
<a name="1d" class="anchor" href="#1d"><span class="octicon octicon-link"></span></a>1d</h2>

<p>Same as [0d], but with all tracked.</p>

<h2>
<a name="1u" class="anchor" href="#1u"><span class="octicon octicon-link"></span></a>1u</h2>

<p>Same as [1], but one untracked file <code>c</code> added.</p>

<pre><code>ls
    #a b c
cat a
    #a1
cat b
    #b1
cat c
    #c1

git status
    #untracked: c

(1)
 |
 master
 HEAD
</code></pre>

<h2>
<a name="1ub" class="anchor" href="#1ub"><span class="octicon octicon-link"></span></a>1ub</h2>

<p>Same as 1ub + one branch.</p>

<p>Current branch is <code>master</code>.</p>

<pre><code>ls
    #a b c
cat a
    #a1
cat b
    #b1
cat c
    #c1

git status
    #untracked: c

(1)
 |
 master *
 b
</code></pre>

<h2>
<a name="2" class="anchor" href="#2"><span class="octicon octicon-link"></span></a>2</h2>

<p>2 commits and 2 files commited.</p>

<pre><code>ls
    #a b
cat a
    #a1
    #a2
cat b
    #b1
    #b2

git status
    #no changes

(1)-----(2)
         |
         HEAD
         master
</code></pre>

<h2>
<a name="2u" class="anchor" href="#2u"><span class="octicon octicon-link"></span></a>2u</h2>

<p>Same as [2] + 1 file uncommited.</p>

<pre><code>ls
    #a b c
cat a
    #a1
    #a2
cat b
    #b1
    #b2
cat c
    #c1
    #c2

git status
    #untracked: c

(1)-----(2)
         |
         HEAD
         master
</code></pre>

<h2>
<a name="2b" class="anchor" href="#2b"><span class="octicon octicon-link"></span></a>2b</h2>

<p>Two branches unmerged, no uncommited files.</p>

<p>Tree:</p>

<pre><code>(1)-----(2)
 |       |
 |       master *
 |
 +------(b2)
         |
         b
</code></pre>

<p>Files:</p>

<pre><code>git checkout master

ls
    #a b c
cat a
    #a1
cat b
    #b1
cat c
    #c1

git checkout b

ls
    #a b c
cat a
    #a1
    #a2
cat b
    #
cat d
    #d1
</code></pre>

<h2>
<a name="3" class="anchor" href="#3"><span class="octicon octicon-link"></span></a>3</h2>

<p>3 commits 2 files.</p>

<p>Looks like:</p>

<pre><code>ls
    #a b
cat a
    #a1
    #a2
    #a3
cat b
    #b1
    #b2
    #b3

git status
    #no changes

(1)-----(2)-----(3)
                 |
                 master *
</code></pre>

<h2>
<a name="0bare" class="anchor" href="#0bare"><span class="octicon octicon-link"></span></a>0bare</h2>

<p>Bare repo.</p>

<h2>
<a name="multi" class="anchor" href="#multi"><span class="octicon octicon-link"></span></a>multi</h2>

<p>Contains multiple repos for inter repo tests.</p>

<p>It looks just like the github fork model!</p>

<p>The repos are:</p>

<pre><code>ls
    #a ao b bo
</code></pre>

<p>Where:</p>

<ul>
<li>ao is the origin of a</li>
<li>ao is the origin of bo</li>
<li>bo is the origin of b</li>
<li>ao is the upstream of b</li>
</ul><p>So that those represent:</p>

<ul>
<li>a is the original repo (same as [b2])</li>
<li>ao is where the owner put it on github</li>
<li>bo is the fork made by someone else on github</li>
<li>b  is the clone of the fork</li>
</ul><p>Also:</p>

<ul>
<li>a has a branch <code>master</code> and a branch <code>b</code>
</li>
</ul><h2>
<a name="multiu" class="anchor" href="#multiu"><span class="octicon octicon-link"></span></a>multiu</h2>

<p>Like [multi], but both master branches have commited unmerged modifications.</p>

<h1>
<a name="definitions" class="anchor" href="#definitions"><span class="octicon octicon-link"></span></a>definitions</h1>

<p>Some git vocabulary.</p>

<h2>
<a name="a-commit" class="anchor" href="#a-commit"><span class="octicon octicon-link"></span></a>a commit</h2>

<p>Is a version.</p>

<h2>
<a name="to-commit" class="anchor" href="#to-commit"><span class="octicon octicon-link"></span></a>to commit</h2>

<p>Is to create version.</p>

<h2>
<a name="to-stage-a-file" class="anchor" href="#to-stage-a-file"><span class="octicon octicon-link"></span></a>to stage a file</h2>

<p>Is to consider it for next commit.</p>

<h2>
<a name="tracked-file" class="anchor" href="#tracked-file"><span class="octicon octicon-link"></span></a>tracked file</h2>

<p>Is one that has already been staged once.</p>

<h2>
<a name="upstream" class="anchor" href="#upstream"><span class="octicon octicon-link"></span></a>upstream</h2>

<p>In general however, upstream is the name for the main repository before you cloned it, <code>origin</code> being the name of your clone.</p>

<p>For example, if you forked <code>he/project</code> into <code>me/project</code>, and clone <code>me/project</code>, the upstream of the cloned repo should be <code>he/project</code>.</p>

<p>In <code>git</code>, <em>upstream</em> has an specific meaning for the <code>push</code> command. A better alternative name also used on the man page is <em>tracking</em> branch, so as not to confuse it with the usual <code>origin</code> <code>upstream</code> workflow terminology.</p>

<h1>
<a name="todo" class="anchor" href="#todo"><span class="octicon octicon-link"></span></a>TODO</h1>

<ul>
<li><p>b clones, a commits, b commits. how can a check b's work
(without clone! withou merge into master, but as a branch at first commit)?</p></li>
<li><p>how to update submodules automatically after a clone (with hooks maybe?)</p></li>
<li><p>how to automatically upload cross platform output files such as pdf (generated from latex)</p></li>
</ul>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>